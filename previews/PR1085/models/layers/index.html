<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model Reference · Flux</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-36890222-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/flux.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Flux</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Building Models</span><ul><li><a class="tocitem" href="../basics/">Basics</a></li><li><a class="tocitem" href="../recurrence/">Recurrence</a></li><li><a class="tocitem" href="../regularisation/">Regularisation</a></li><li class="is-active"><a class="tocitem" href>Model Reference</a><ul class="internal"><li><a class="tocitem" href="#Basic-Layers-1"><span>Basic Layers</span></a></li><li><a class="tocitem" href="#Convolution-and-Pooling-Layers-1"><span>Convolution and Pooling Layers</span></a></li><li><a class="tocitem" href="#Recurrent-Layers-1"><span>Recurrent Layers</span></a></li><li><a class="tocitem" href="#Other-General-Purpose-Layers-1"><span>Other General Purpose Layers</span></a></li><li><a class="tocitem" href="#Normalisation-and-Regularisation-1"><span>Normalisation &amp; Regularisation</span></a></li><li><a class="tocitem" href="#Cost-Functions-1"><span>Cost Functions</span></a></li></ul></li><li><a class="tocitem" href="../advanced/">Advanced Model Building</a></li><li><a class="tocitem" href="../nnlib/">NNlib</a></li></ul></li><li><span class="tocitem">Handling Data</span><ul><li><a class="tocitem" href="../../data/onehot/">One-Hot Encoding</a></li><li><a class="tocitem" href="../../data/dataloader/">DataLoader</a></li></ul></li><li><span class="tocitem">Training Models</span><ul><li><a class="tocitem" href="../../training/optimisers/">Optimisers</a></li><li><a class="tocitem" href="../../training/training/">Training</a></li></ul></li><li><a class="tocitem" href="../../gpu/">GPU Support</a></li><li><a class="tocitem" href="../../saving/">Saving &amp; Loading</a></li><li><a class="tocitem" href="../../ecosystem/">The Julia Ecosystem</a></li><li><a class="tocitem" href="../../performance/">Performance Tips</a></li><li><a class="tocitem" href="../../community/">Community</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Building Models</a></li><li class="is-active"><a href>Model Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FluxML/Flux.jl/blob/master/docs/src/models/layers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Basic-Layers-1"><a class="docs-heading-anchor" href="#Basic-Layers-1">Basic Layers</a><a class="docs-heading-anchor-permalink" href="#Basic-Layers-1" title="Permalink"></a></h2><p>These core layers form the foundation of almost all neural networks.</p><article class="docstring"><header><a class="docstring-binding" id="Flux.Chain" href="#Flux.Chain"><code>Flux.Chain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Chain(layers...)</code></pre><p>Chain multiple layers / functions together, so that they are called in sequence on a given input.</p><pre><code class="language-julia">m = Chain(x -&gt; x^2, x -&gt; x+1)
m(5) == 26

m = Chain(Dense(10, 5), Dense(5, 2))
x = rand(10)
m(x) == m[2](m[1](x))</code></pre><p><code>Chain</code> also supports indexing and slicing, e.g. <code>m[2]</code> or <code>m[1:end-1]</code>. <code>m[1:3](x)</code> will calculate the output of the first three layers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/basic.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.Dense" href="#Flux.Dense"><code>Flux.Dense</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Dense(in::Integer, out::Integer, σ = identity)</code></pre><p>Creates a traditional <code>Dense</code> layer with parameters <code>W</code> and <code>b</code>.</p><pre><code class="language-none">y = σ.(W * x .+ b)</code></pre><p>The input <code>x</code> must be a vector of length <code>in</code>, or a batch of vectors represented as an <code>in × N</code> matrix. The out <code>y</code> will be a vector or batch of length <code>out</code>.</p><pre><code class="language-julia">julia&gt; d = Dense(5, 2)
Dense(5, 2)

julia&gt; d(rand(5))
Array{Float64,1}:
  0.00257447
  -0.00449443</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/basic.jl#L78-L97">source</a></section></article><h2 id="Convolution-and-Pooling-Layers-1"><a class="docs-heading-anchor" href="#Convolution-and-Pooling-Layers-1">Convolution and Pooling Layers</a><a class="docs-heading-anchor-permalink" href="#Convolution-and-Pooling-Layers-1" title="Permalink"></a></h2><p>These layers are used to build convolutional neural networks (CNNs).</p><article class="docstring"><header><a class="docstring-binding" id="Flux.Conv" href="#Flux.Conv"><code>Flux.Conv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Conv(size, in=&gt;out)
Conv(size, in=&gt;out, relu)</code></pre><p>Standard convolutional layer. <code>size</code> should be a tuple like <code>(2, 2)</code>. <code>in</code> and <code>out</code> specify the number of input and output channels respectively.</p><p>Example: Applying Conv layer to a 1-channel input using a 2x2 window size,          giving us a 16-channel output. Output is activated with ReLU.</p><pre><code class="language-none">size = (2,2)
in = 1
out = 16
Conv((2, 2), 1=&gt;16, relu)</code></pre><p>Data should be stored in WHCN order (width, height, # channels, batch size). In other words, a 100×100 RGB image would be a <code>100×100×3×1</code> array, and a batch of 50 would be a <code>100×100×3×50</code> array.</p><p>Takes the keyword arguments <code>pad</code>, <code>stride</code> and <code>dilation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/conv.jl#L10-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.MaxPool" href="#Flux.MaxPool"><code>Flux.MaxPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MaxPool(k)</code></pre><p>Max pooling layer. <code>k</code> stands for the size of the window for each dimension of the input.</p><p>Takes the keyword arguments <code>pad</code> and <code>stride</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/conv.jl#L359-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.GlobalMaxPool" href="#Flux.GlobalMaxPool"><code>Flux.GlobalMaxPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GlobalMaxPool()</code></pre><p>Global max pooling layer.</p><p>Transforms (w,h,c,b)-shaped input into (1,1,c,b)-shaped output, by performing max pooling on the complete (w,h)-shaped feature maps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/conv.jl#L309-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.MeanPool" href="#Flux.MeanPool"><code>Flux.MeanPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MeanPool(k)</code></pre><p>Mean pooling layer. <code>k</code> stands for the size of the window for each dimension of the input.</p><p>Takes the keyword arguments <code>pad</code> and <code>stride</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/conv.jl#L390-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.GlobalMeanPool" href="#Flux.GlobalMeanPool"><code>Flux.GlobalMeanPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GlobalMeanPool()</code></pre><p>Global mean pooling layer.</p><p>Transforms (w,h,c,b)-shaped input into (1,1,c,b)-shaped output, by performing mean pooling on the complete (w,h)-shaped feature maps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/conv.jl#L334-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.DepthwiseConv" href="#Flux.DepthwiseConv"><code>Flux.DepthwiseConv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DepthwiseConv(size, in=&gt;out)
DepthwiseConv(size, in=&gt;out, relu)</code></pre><p>Depthwise convolutional layer. <code>size</code> should be a tuple like <code>(2, 2)</code>. <code>in</code> and <code>out</code> specify the number of input and output channels respectively. Note that <code>out</code> must be an integer multiple of <code>in</code>.</p><p>Data should be stored in WHCN order (width, height, # channels, # batches). In other words, a 100×100 RGB image would be a <code>100×100×3×1</code> array, and a batch of 50 would be a <code>100×100×3×50</code> array.</p><p>Takes the keyword arguments <code>pad</code>, <code>stride</code> and <code>dilation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/conv.jl#L167-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.ConvTranspose" href="#Flux.ConvTranspose"><code>Flux.ConvTranspose</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConvTranspose(size, in=&gt;out)
ConvTranspose(size, in=&gt;out, relu)</code></pre><p>Standard convolutional transpose layer. <code>size</code> should be a tuple like <code>(2, 2)</code>. <code>in</code> and <code>out</code> specify the number of input and output channels respectively.</p><p>Data should be stored in WHCN order (width, height, # channels, # batches). In other words, a 100×100 RGB image would be a <code>100×100×3×1</code> array, and a batch of 50 would be a <code>100×100×3×50</code> array.</p><p>Takes the keyword arguments <code>pad</code>, <code>stride</code> and <code>dilation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/conv.jl#L91-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.CrossCor" href="#Flux.CrossCor"><code>Flux.CrossCor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CrossCor(size, in=&gt;out)
CrossCor(size, in=&gt;out, relu)</code></pre><p>Standard cross convolutional layer. <code>size</code> should be a tuple like <code>(2, 2)</code>. <code>in</code> and <code>out</code> specify the number of input and output channels respectively.</p><p>Example: Applying CrossCor layer to a 1-channel input using a 2x2 window size,          giving us a 16-channel output. Output is activated with ReLU.</p><pre><code class="language-none">size = (2,2)
in = 1
out = 16
CrossCor((2, 2), 1=&gt;16, relu)</code></pre><p>Data should be stored in WHCN order (width, height, # channels, # batches). In other words, a 100×100 RGB image would be a <code>100×100×3×1</code> array, and a batch of 50 would be a <code>100×100×3×50</code> array.</p><p>Takes the keyword arguments <code>pad</code>, <code>stride</code> and <code>dilation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/conv.jl#L235-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.flatten" href="#Flux.flatten"><code>Flux.flatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">flatten(x::AbstractArray)</code></pre><p>Transforms (w,h,c,b)-shaped input into (w x h x c,b)-shaped output, by linearizing all values for each element in the batch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/stateless.jl#L204-L209">source</a></section></article><h2 id="Recurrent-Layers-1"><a class="docs-heading-anchor" href="#Recurrent-Layers-1">Recurrent Layers</a><a class="docs-heading-anchor-permalink" href="#Recurrent-Layers-1" title="Permalink"></a></h2><p>Much like the core layers above, but can be used to process sequence data (as well as other kinds of structured data).</p><article class="docstring"><header><a class="docstring-binding" id="Flux.RNN" href="#Flux.RNN"><code>Flux.RNN</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RNN(in::Integer, out::Integer, σ = tanh)</code></pre><p>The most basic recurrent layer; essentially acts as a <code>Dense</code> layer, but with the output fed back into the input each time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/recurrent.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.LSTM" href="#Flux.LSTM"><code>Flux.LSTM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">LSTM(in::Integer, out::Integer)</code></pre><p>Long Short Term Memory recurrent layer. Behaves like an RNN but generally exhibits a longer memory span over sequences.</p><p>See <a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">this article</a> for a good overview of the internals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/recurrent.jl#L135-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.GRU" href="#Flux.GRU"><code>Flux.GRU</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">GRU(in::Integer, out::Integer)</code></pre><p>Gated Recurrent Unit layer. Behaves like an RNN but generally exhibits a longer memory span over sequences.</p><p>See <a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">this article</a> for a good overview of the internals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/recurrent.jl#L176-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.Recur" href="#Flux.Recur"><code>Flux.Recur</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Recur(cell)</code></pre><p><code>Recur</code> takes a recurrent cell and makes it stateful, managing the hidden state in the background. <code>cell</code> should be a model of the form:</p><pre><code class="language-none">h, y = cell(h, x...)</code></pre><p>For example, here&#39;s a recurrent network that keeps a running total of its inputs.</p><pre><code class="language-julia">accum(h, x) = (h+x, x)
rnn = Flux.Recur(accum, 0)
rnn(2) # 2
rnn(3) # 3
rnn.state # 5
rnn.(1:10) # apply to a sequence
rnn.state # 60</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/recurrent.jl#L7-L26">source</a></section></article><h2 id="Other-General-Purpose-Layers-1"><a class="docs-heading-anchor" href="#Other-General-Purpose-Layers-1">Other General Purpose Layers</a><a class="docs-heading-anchor-permalink" href="#Other-General-Purpose-Layers-1" title="Permalink"></a></h2><p>These are marginally more obscure than the Basic Layers. But in contrast to the layers described in the other sections are not readily grouped around a particular purpose (e.g. CNNs or RNNs).</p><article class="docstring"><header><a class="docstring-binding" id="Flux.Maxout" href="#Flux.Maxout"><code>Flux.Maxout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Maxout(over)</code></pre><p><code>Maxout</code> is a neural network layer, which has a number of internal layers, which all have the same input, and the maxout returns the elementwise maximium of the internal layers&#39; outputs.</p><p>Maxout over linear dense layers satisfies the univeral approximation theorem.</p><p>Reference: Ian J. Goodfellow, David Warde-Farley, Mehdi Mirza, Aaron Courville, and Yoshua Bengio.</p><ol><li>Maxout networks.</li></ol><p>In Proceedings of the 30th International Conference on International Conference on Machine Learning - Volume 28 (ICML&#39;13), Sanjoy Dasgupta and David McAllester (Eds.), Vol. 28. JMLR.org III-1319-III-1327. https://arxiv.org/pdf/1302.4389.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/basic.jl#L176-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.SkipConnection" href="#Flux.SkipConnection"><code>Flux.SkipConnection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SkipConnection(layers, connection)</code></pre><p>Creates a Skip Connection, of a layer or <code>Chain</code> of consecutive layers plus a shortcut connection. The connection function will combine the result of the layers with the original input, to give the final output.</p><p>The simplest &#39;ResNet&#39;-type connection is just <code>SkipConnection(layer, +)</code>, and requires the output of the layers to be the same shape as the input. Here is a more complicated example:</p><pre><code class="language-none">m = Conv((3,3), 4=&gt;7, pad=(1,1))
x = ones(5,5,4,10);
size(m(x)) == (5, 5, 7, 10)

sm = SkipConnection(m, (mx, x) -&gt; cat(mx, x, dims=3))
size(sm(x)) == (5, 5, 11, 10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/basic.jl#L225-L243">source</a></section></article><h2 id="Normalisation-and-Regularisation-1"><a class="docs-heading-anchor" href="#Normalisation-and-Regularisation-1">Normalisation &amp; Regularisation</a><a class="docs-heading-anchor-permalink" href="#Normalisation-and-Regularisation-1" title="Permalink"></a></h2><p>These layers don&#39;t affect the structure of the network but may improve training times or reduce overfitting.</p><article class="docstring"><header><a class="docstring-binding" id="Flux.BatchNorm" href="#Flux.BatchNorm"><code>Flux.BatchNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BatchNorm(channels::Integer, σ = identity;
          initβ = zeros, initγ = ones,
          ϵ = 1e-8, momentum = .1)</code></pre><p>Batch Normalization layer. The <code>channels</code> input should be the size of the channel dimension in your data (see below).</p><p>Given an array with <code>N</code> dimensions, call the <code>N-1</code>th the channel dimension. (For a batch of feature vectors this is just the data dimension, for <code>WHCN</code> images it&#39;s the usual channel dimension.)</p><p><code>BatchNorm</code> computes the mean and variance for each each <code>W×H×1×N</code> slice and shifts them to have a new mean and variance (corresponding to the learnable, per-channel <code>bias</code> and <code>scale</code> parameters).</p><p>Use <a href="#Flux.testmode!"><code>testmode!</code></a> during inference.</p><p>See <a href="https://arxiv.org/pdf/1502.03167.pdf">Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a>.</p><p>Example:</p><pre><code class="language-julia">m = Chain(
  Dense(28^2, 64),
  BatchNorm(64, relu),
  Dense(64, 10),
  BatchNorm(10),
  softmax)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/normalise.jl#L121-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.Dropout" href="#Flux.Dropout"><code>Flux.Dropout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Dropout(p, dims = :)</code></pre><p>A Dropout layer. In the forward pass, applies the <a href="#Flux.dropout"><code>dropout</code></a> function on the input.</p><p>Does nothing to the input once <a href="#Flux.testmode!"><code>testmode!</code></a> is true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/normalise.jl#L30-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.dropout" href="#Flux.dropout"><code>Flux.dropout</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dropout(p, dims = :)</code></pre><p>Dropout function. For each input, either sets that input to <code>0</code> (with probability <code>p</code>) or scales it by <code>1/(1-p)</code>. The <code>dims</code> argument is to specify the unbroadcasted dimensions, i.e. <code>dims=1</code> does dropout along columns and <code>dims=2</code> along rows. This is used as a regularisation, i.e. it reduces overfitting during training. </p><p>See also <a href="#Flux.Dropout"><code>Dropout</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/normalise.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.AlphaDropout" href="#Flux.AlphaDropout"><code>Flux.AlphaDropout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AlphaDropout(p)</code></pre><p>A dropout layer. It is used in Self-Normalizing Neural Networks. (https://papers.nips.cc/paper/6698-self-normalizing-neural-networks.pdf) The AlphaDropout layer ensures that mean and variance of activations remains the same as before.</p><p>Does nothing to the input once <a href="#Flux.testmode!"><code>testmode!</code></a> is true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/normalise.jl#L65-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.LayerNorm" href="#Flux.LayerNorm"><code>Flux.LayerNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LayerNorm(h::Integer)</code></pre><p>A <a href="https://arxiv.org/pdf/1607.06450.pdf">normalisation layer</a> designed to be used with recurrent hidden states of size <code>h</code>. Normalises the mean/stddev of each input before applying a per-neuron gain/bias.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/normalise.jl#L99-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.GroupNorm" href="#Flux.GroupNorm"><code>Flux.GroupNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Group Normalization. This layer can outperform Batch-Normalization and Instance-Normalization.</p><pre><code class="language-none">GroupNorm(chs::Integer, G::Integer, λ = identity;
          initβ = (i) -&gt; zeros(Float32, i), initγ = (i) -&gt; ones(Float32, i),
          ϵ = 1f-5, momentum = 0.1f0)</code></pre><p><span>$chs$</span> is the number of channels, the channel dimension of your input. For an array of N dimensions, the (N-1)th index is the channel dimension.</p><p><span>$G$</span> is the number of groups along which the statistics would be computed. The number of channels must be an integer multiple of the number of groups.</p><p>Use <a href="#Flux.testmode!"><code>testmode!</code></a> during inference.</p><p>Example:</p><pre><code class="language-none">m = Chain(Conv((3,3), 1=&gt;32, leakyrelu;pad = 1),
          GroupNorm(32,16)) # 32 channels, 16 groups (G = 16), thus 2 channels per group used</code></pre><p>Link : https://arxiv.org/pdf/1803.08494.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/normalise.jl#L318-L341">source</a></section></article><h3 id="Testmode-1"><a class="docs-heading-anchor" href="#Testmode-1">Testmode</a><a class="docs-heading-anchor-permalink" href="#Testmode-1" title="Permalink"></a></h3><p>Many normalisation layers behave differently under training and inference (testing). By default, Flux will automatically determine when a layer evaluation is part of training or inference. Still, depending on your use case, it may be helpful to manually specify when these layers should be treated as being trained or not. For this, Flux provides <code>testmode!</code>. When called on a model (e.g. a layer or chain of layers), this function will place the model into the mode specified.</p><article class="docstring"><header><a class="docstring-binding" id="Flux.testmode!" href="#Flux.testmode!"><code>Flux.testmode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">testmode!(m, mode = true)</code></pre><p>Set a layer or model&#39;s test mode (see below). Using <code>:auto</code> mode will treat any gradient computation as training.</p><p><em>Note</em>: if you manually set a model into test mode, you need to manually place it back into train mode during training phase.</p><p>Possible values include:</p><ul><li><code>false</code> for training</li><li><code>true</code> for testing</li><li><code>:auto</code> or <code>nothing</code> for Flux to detect the mode automatically</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/functor.jl#L42-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.trainmode!" href="#Flux.trainmode!"><code>Flux.trainmode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trainmode!(m, mode = true)</code></pre><p>Set a layer of model&#39;s train mode (see below). Symmetric to <a href="#Flux.testmode!"><code>testmode!</code></a> (i.e. `trainmode!(m, mode) == testmode!(m, !mode)).</p><p><em>Note</em>: if you manually set a model into train mode, you need to manually place it into test mode during testing phase.</p><p>Possible values include:</p><ul><li><code>true</code> for training</li><li><code>false</code> for testing</li><li><code>:auto</code> or <code>nothing</code> for Flux to detect the mode automatically</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/functor.jl#L58-L71">source</a></section></article><h2 id="Cost-Functions-1"><a class="docs-heading-anchor" href="#Cost-Functions-1">Cost Functions</a><a class="docs-heading-anchor-permalink" href="#Cost-Functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Flux.mae" href="#Flux.mae"><code>Flux.mae</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mae(ŷ, y)</code></pre><p>Return the mean of absolute error <code>sum(abs.(ŷ .- y)) / length(y)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/stateless.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.mse" href="#Flux.mse"><code>Flux.mse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mse(ŷ, y)</code></pre><p>Return the mean squared error <code>sum((ŷ .- y).^2) / length(y)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/stateless.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.msle" href="#Flux.msle"><code>Flux.msle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">msle(ŷ, y; ϵ=eps(eltype(ŷ)))</code></pre><p>Returns the mean of the squared logarithmic errors <code>sum((log.(ŷ .+ ϵ) .- log.(y .+ ϵ)).^2) / length(y)</code>. The <code>ϵ</code> term provides numerical stability.</p><p>This error penalizes an under-predicted estimate greater than an over-predicted estimate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/stateless.jl#L18-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.huber_loss" href="#Flux.huber_loss"><code>Flux.huber_loss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">huber_loss(ŷ, y; δ=1.0)</code></pre><p>Computes the mean of the Huber loss given the prediction <code>ŷ</code> and true values <code>y</code>. By default, δ is set to 1.0.</p><pre><code class="language-none">                | 0.5*|ŷ - y|,   for |ŷ - y| &lt;= δ
  Hubber loss = |
                |  δ*(|ŷ - y| - 0.5*δ),  otherwise</code></pre><p><a href="https://en.wikipedia.org/wiki/Huber_loss"><code>Huber Loss</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/stateless.jl#L30-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.crossentropy" href="#Flux.crossentropy"><code>Flux.crossentropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">crossentropy(ŷ, y; weight=1)</code></pre><p>Return the crossentropy computed as <code>-sum(y .* log.(ŷ) .* weight) / size(y, 2)</code>.</p><p>See also <a href="#Flux.logitcrossentropy"><code>logitcrossentropy</code></a>, <a href="#Flux.binarycrossentropy"><code>binarycrossentropy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/stateless.jl#L60-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.logitcrossentropy" href="#Flux.logitcrossentropy"><code>Flux.logitcrossentropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">logitcrossentropy(ŷ, y; weight=1)</code></pre><p>Return the crossentropy computed after a <a href="models/@ref">softmax</a> operation:</p><p>-sum(y .* logsoftmax(ŷ) .* weight) / size(y, 2)</p><p>See also <a href="#Flux.crossentropy"><code>crossentropy</code></a>, <a href="#Flux.binarycrossentropy"><code>binarycrossentropy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/stateless.jl#L69-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.binarycrossentropy" href="#Flux.binarycrossentropy"><code>Flux.binarycrossentropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">binarycrossentropy(ŷ, y; ϵ=eps(ŷ))</code></pre><p>Return <code>-y*log(ŷ + ϵ) - (1-y)*log(1-ŷ + ϵ)</code>. The ϵ term provides numerical stability.</p><p>Typically, the prediction <code>ŷ</code> is given by the output of a <a href="../nnlib/#NNlib.sigmoid"><code>sigmoid</code></a> activation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/stateless.jl#L82-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.logitbinarycrossentropy" href="#Flux.logitbinarycrossentropy"><code>Flux.logitbinarycrossentropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">logitbinarycrossentropy(ŷ, y)</code></pre><p><code>logitbinarycrossentropy(ŷ, y)</code> is mathematically equivalent to <code>binarycrossentropy(σ(ŷ), y)</code> but it is more numerically stable.</p><p>See also <a href="#Flux.binarycrossentropy"><code>binarycrossentropy</code></a>, <a href="../nnlib/#NNlib.sigmoid"><code>sigmoid</code></a>, <a href="../nnlib/#NNlib.logsigmoid"><code>logsigmoid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/stateless.jl#L94-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.kldivergence" href="#Flux.kldivergence"><code>Flux.kldivergence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kldivergence(ŷ, y)</code></pre><p>KLDivergence is a measure of how much one probability distribution is different from the other. It is always non-negative and zero only when both the distributions are equal everywhere.</p><p><a href="https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence">KL Divergence</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/stateless.jl#L138-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.poisson" href="#Flux.poisson"><code>Flux.poisson</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">poisson(ŷ, y)</code></pre><p>Poisson loss function is a measure of how the predicted distribution diverges from the expected distribution. Returns <code>sum(ŷ .- y .* log.(ŷ)) / size(y, 2)</code></p><p><a href="https://peltarion.com/knowledge-center/documentation/modeling-view/build-an-ai-model/loss-functions/poisson">Poisson Loss</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/stateless.jl#L152-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.hinge" href="#Flux.hinge"><code>Flux.hinge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hinge(ŷ, y)</code></pre><p>Measures the loss given the prediction <code>ŷ</code> and true labels <code>y</code> (containing 1 or -1). Returns <code>sum((max.(0, 1 .- ŷ .* y))) / size(y, 2)</code></p><p><a href="https://en.wikipedia.org/wiki/Hinge_loss">Hinge Loss</a> See also <a href="#Flux.squared_hinge"><code>squared_hinge</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/stateless.jl#L162-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.squared_hinge" href="#Flux.squared_hinge"><code>Flux.squared_hinge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">squared_hinge(ŷ, y)</code></pre><p>Computes squared hinge loss given the prediction <code>ŷ</code> and true labels <code>y</code> (conatining 1 or -1). Returns <code>sum((max.(0, 1 .- ŷ .* y)).^2) / size(y, 2)</code></p><p>See also <a href="#Flux.hinge"><code>hinge</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/stateless.jl#L173-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.dice_coeff_loss" href="#Flux.dice_coeff_loss"><code>Flux.dice_coeff_loss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dice_coeff_loss(ŷ, y; smooth=1)</code></pre><p>Loss function used in Image Segmentation. Calculates loss based on dice coefficient. Similar to F1_score. Returns <code>1 - 2*sum(|ŷ .* y| + smooth) / (sum(ŷ.^2) + sum(y.^2) + smooth)</code></p><p><a href="https://arxiv.org/pdf/1606.04797v1.pdf">V-Net: Fully Convolutional Neural Networks forVolumetric Medical Image Segmentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/stateless.jl#L183-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.tversky_loss" href="#Flux.tversky_loss"><code>Flux.tversky_loss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tversky_loss(ŷ, y; β=0.7)</code></pre><p>Used with imbalanced data to give more weightage to False negatives. Larger β weigh recall higher than precision (by placing more emphasis on false negatives) Returns <code>1 - sum(|y .* ŷ| + 1) / (sum(y .* ŷ + β*(1 .- y) .* ŷ + (1 - β)*y .* (1 .- ŷ)) + 1)</code></p><p><a href="https://arxiv.org/pdf/1706.05721.pdf">Tversky loss function for image segmentation using 3D fully convolutional deep networks</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/2a5080e334f7b47e5d5bfe06f9b2dc477adee709/src/layers/stateless.jl#L193-L201">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../regularisation/">« Regularisation</a><a class="docs-footer-nextpage" href="../advanced/">Advanced Model Building »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 14 March 2020 18:23">Saturday 14 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
