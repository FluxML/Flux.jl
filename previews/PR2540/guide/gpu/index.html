<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GPU Support · Flux</title><meta name="title" content="GPU Support · Flux"/><meta property="og:title" content="GPU Support · Flux"/><meta property="twitter:title" content="GPU Support · Flux"/><meta name="description" content="Documentation for Flux."/><meta property="og:description" content="Documentation for Flux."/><meta property="twitter:description" content="Documentation for Flux."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-36890222-9"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-36890222-9', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/flux.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="Flux logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="Flux logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../models/quickstart/">Quick Start</a></li><li><a class="tocitem" href="../models/overview/">Fitting a Line</a></li><li><a class="tocitem" href="../models/basics/">Gradients and Layers</a></li><li><a class="tocitem" href="../models/custom_layers/">Custom Layers</a></li><li><a class="tocitem" href="../training/training/">Training</a></li><li><a class="tocitem" href="../models/recurrence/">Recurrence</a></li><li class="is-active"><a class="tocitem" href>GPU Support</a><ul class="internal"><li><a class="tocitem" href="#Basic-GPU-use:-from-Array-to-CuArray"><span>Basic GPU use: from <code>Array</code> to <code>CuArray</code></span></a></li><li><a class="tocitem" href="#Other-GPU-packages-for-AMD-and-Apple"><span>Other GPU packages for AMD &amp; Apple</span></a></li><li><a class="tocitem" href="#Automatic-GPU-choice-with-gpu-and-gpu_device"><span>Automatic GPU choice with <code>gpu</code> and <code>gpu_device</code></span></a></li><li><a class="tocitem" href="#Transferring-Training-Data"><span>Transferring Training Data</span></a></li><li><a class="tocitem" href="#Saving-GPU-Trained-Models"><span>Saving GPU-Trained Models</span></a></li><li><a class="tocitem" href="#Disabling-CUDA-or-choosing-which-GPUs-are-visible-to-Flux"><span>Disabling CUDA or choosing which GPUs are visible to Flux</span></a></li><li><a class="tocitem" href="#Data-movement-across-GPU-devices"><span>Data movement across GPU devices</span></a></li><li><a class="tocitem" href="#Distributed-data-parallel-training"><span>Distributed data parallel training</span></a></li><li><a class="tocitem" href="#Checking-GPU-Availability"><span>Checking GPU Availability</span></a></li></ul></li><li><a class="tocitem" href="../saving/">Saving &amp; Loading</a></li><li><a class="tocitem" href="../performance/">Performance Tips</a></li></ul></li><li><a class="tocitem" href="../../ecosystem/">Ecosystem</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference/models/layers/">Built-in Layers</a></li><li><a class="tocitem" href="../../reference/models/activation/">Activation Functions</a></li><li><a class="tocitem" href="../../reference/utilities/">Weight Initialisation</a></li><li><a class="tocitem" href="../../reference/models/losses/">Loss Functions</a></li><li><a class="tocitem" href="../../reference/training/reference/">Training API</a></li><li><a class="tocitem" href="../../reference/training/optimisers/">Optimisation Rules</a></li><li><a class="tocitem" href="../../reference/outputsize/">Shape Inference</a></li><li><a class="tocitem" href="../../reference/destructure/">Flat vs. Nested</a></li><li><a class="tocitem" href="../../reference/training/callbacks/">Callback Helpers</a></li><li><a class="tocitem" href="../../reference/training/zygote/">Gradients – Zygote.jl</a></li><li><a class="tocitem" href="../../reference/training/enzyme/">Gradients – Enzyme.jl</a></li><li><a class="tocitem" href="../../reference/data/mldatadevices/">Transfer Data to GPU – MLDataDevices.jl</a></li><li><a class="tocitem" href="../../reference/data/mlutils/">Batching Data – MLUtils.jl</a></li><li><a class="tocitem" href="../../reference/data/onehot/">OneHotArrays.jl</a></li><li><a class="tocitem" href="../../reference/models/nnlib/">Low-level Operations – NNlib.jl</a></li><li><a class="tocitem" href="../../reference/models/functors/">Nested Structures – Functors.jl</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/linear_regression/">Linear Regression</a></li><li><a class="tocitem" href="../../tutorials/logistic_regression/">Logistic Regression</a></li><li><a class="tocitem" href="../../tutorials/model_zoo/">Model Zoo</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Guide</a></li><li class="is-active"><a href>GPU Support</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>GPU Support</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/FluxML/Flux.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/FluxML/Flux.jl/blob/master/docs/src/guide/gpu.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="GPU-Support"><a class="docs-heading-anchor" href="#GPU-Support">GPU Support</a><a id="GPU-Support-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-Support" title="Permalink"></a></h1><p>Most work on neural networks involves the use of GPUs, as they can typically perform the required computation much faster. This page describes how Flux co-operates with various other packages, which talk to GPU hardware.</p><p>For those in a hurry, see the <a href="../models/quickstart/#man-quickstart">quickstart</a> page. Or do <code>using CUDA</code> and then call <code>gpu</code> on both the model and the data. </p><h2 id="Basic-GPU-use:-from-Array-to-CuArray"><a class="docs-heading-anchor" href="#Basic-GPU-use:-from-Array-to-CuArray">Basic GPU use: from <code>Array</code> to <code>CuArray</code></a><a id="Basic-GPU-use:-from-Array-to-CuArray-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-GPU-use:-from-Array-to-CuArray" title="Permalink"></a></h2><p>Julia&#39;s GPU packages work with special array types, in place of the built-in <code>Array</code>. The most used is <code>CuArray</code> provided by <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a>, for GPUs made by NVIDIA. That package provides a function <code>cu</code> which converts an ordinary <code>Array</code> (living in CPu memory) to a <code>CuArray</code> (living in GPU memory). Functions like <code>*</code> and broadcasting specialise so that, when given <code>CuArray</code>s, all the computation happens on the GPU:</p><pre><code class="language-julia hljs">W = randn(3, 4)  # some weights, on CPU: 3×4 Array{Float64, 2}
x = randn(4)     # fake data
y = tanh.(W * x) # computation on the CPU

using CUDA

cu(W) isa CuArray{Float32}
(cW, cx) = (W, x) |&gt; cu  # move both to GPU
cy = tanh.(cW * cx)      # computation on the GPU</code></pre><p>Notice that <code>cu</code> doesn&#39;t only move arrays, it also recurses into many structures, such as the tuple <code>(W, x)</code> above. (Notice also that it converts Julia&#39;s default <code>Float64</code> numbers to <code>Float32</code>, as this is what most GPUs support efficiently – it calls itself &quot;opinionated&quot;. Flux defaults to <code>Float32</code> in all cases.)</p><p>To use CUDA with Flux, you can simply use <code>cu</code> to move both the model, and the data. It will create a copy of the Flux model, with all of its parameter arrays moved to the GPU:</p><pre><code class="language-julia hljs">using Pkg; Pkg.add([&quot;CUDA&quot;, &quot;cuDNN&quot;])  # do this once

using Flux, CUDA
CUDA.allowscalar(false)  # recommended

model = Dense(W, true, tanh)  # wrap the same matrix W in a Flux layer
model(x) ≈ y                  # same result, still on CPU

c_model = cu(model)  # move all the arrays within model to the GPU
c_model(cx)          # computation on the GPU</code></pre><p>Notice that you need <code>using CUDA</code> (every time) but also <code>] add cuDNN</code> (once, when installing packages). This is a quirk of how these packages are set up. (The <a href="https://github.com/JuliaGPU/CUDA.jl/tree/master/lib/cudnn"><code>cuDNN.jl</code></a> sub-package handles operations such as convolutions, called by Flux via <a href="https://github.com/FluxML/NNlib.jl">NNlib.jl</a>.)</p><p>Flux&#39;s <code>gradient</code>, and training functions like <code>setup</code>, <code>update!</code>, and <code>train!</code>, are all equally happy to accept GPU arrays and GPU models, and then perform all computations on the GPU. It is recommended that you move the model to the GPU before calling <code>setup</code>.</p><pre><code class="language-julia hljs">grads = Flux.gradient((f,x) -&gt; sum(abs2, f(x)), model, x)  # on CPU
c_grads = Flux.gradient((f,x) -&gt; sum(abs2, f(x)), c_model, cx)  # same result, all on GPU

c_opt = Flux.setup(Adam(), c_model)  # setup optimiser after moving model to GPU

Flux.update!(c_opt, c_model, c_grads[1])  # mutates c_model but not model</code></pre><p>To move arrays and other objects back to the CPU, Flux provides a function <code>cpu</code>. This is recommended when saving models, <code>Flux.state(c_model |&gt; cpu)</code>, see below.</p><pre><code class="language-julia hljs">cpu(cW) isa Array{Float32, 2}

model2 = cpu(c_model)  # copy model back to CPU
model2(x)</code></pre><div class="admonition is-compat"><header class="admonition-header">Flux ≤ 0.13</header><div class="admonition-body"><p>Old versions of Flux automatically loaded CUDA.jl to provide GPU support. Starting from Flux v0.14, it has to be  loaded separately. Julia&#39;s <a href="https://pkgdocs.julialang.org/v1/creating-packages/#Conditional-loading-of-code-in-packages-(Extensions)">package extensions</a> allow Flux to automatically load some GPU-specific code when needed.</p></div></div><h2 id="Other-GPU-packages-for-AMD-and-Apple"><a class="docs-heading-anchor" href="#Other-GPU-packages-for-AMD-and-Apple">Other GPU packages for AMD &amp; Apple</a><a id="Other-GPU-packages-for-AMD-and-Apple-1"></a><a class="docs-heading-anchor-permalink" href="#Other-GPU-packages-for-AMD-and-Apple" title="Permalink"></a></h2><p>Non-NVIDIA graphics cards are supported by other packages. Each provides its own function which behaves like <code>cu</code>. AMD GPU support provided by <a href="https://github.com/JuliaGPU/AMDGPU.jl">AMDGPU.jl</a>, on systems with ROCm and MIOpen installed. This package has a function <code>roc</code> which converts <code>Array</code> to <code>ROCArray</code>:</p><pre><code class="language-julia hljs">using Flux, AMDGPU
AMDGPU.allowscalar(false)

r_model = roc(model)
r_model(roc(x))

Flux.gradient((f,x) -&gt; sum(abs2, f(x)), r_model, roc(x))</code></pre><p>Experimental support for Apple devices with M-series chips is provided by  <a href="https://github.com/JuliaGPU/Metal.jl">Metal.jl</a>. This has a function <a href="https://metal.juliagpu.org/stable/api/array/#Metal.mtl"><code>mtl</code></a> which works like <code>cu</code>, converting <code>Array</code> to <code>MtlArray</code>:</p><pre><code class="language-julia hljs">using Flux, Metal
Metal.allowscalar(false)

m_model = mtl(model)
m_y = m_model(mtl(x))

Flux.gradient((f,x) -&gt; sum(abs2, f(x)), m_model, mtl(x))</code></pre><div class="admonition is-danger"><header class="admonition-header">Experimental</header><div class="admonition-body"><p>Metal support in Flux is experimental and many features are not yet available. AMD support is improving, but likely to have more rough edges than CUDA.</p></div></div><p>If you want your model to work with any brand of GPU, or none, then you may not wish to write <code>cu</code> everywhere. One simple way to be generic is, at the top of the file, to un-comment one of several lines which import a package and assign its &quot;adaptor&quot; to the same name:</p><pre><code class="language-julia hljs">using CUDA: cu as device  # after this, `device === cu`
# using AMDGPU: roc as device
# device = identity  # do-nothing, for CPU

using Flux
model = Chain(...) |&gt; device</code></pre><div class="admonition is-info"><header class="admonition-header">Adapt.jl</header><div class="admonition-body"><p>The functions <code>cu</code>, <code>mtl</code>, <code>roc</code> all use <a href="https://github.com/JuliaGPU/Adapt.jl">Adapt.jl</a>, to work within various wrappers. The reason they work on Flux models is that <code>Flux.@layer Layer</code> defines methods of <code>Adapt.adapt_structure(to, lay::Layer)</code>.</p></div></div><h2 id="Automatic-GPU-choice-with-gpu-and-gpu_device"><a class="docs-heading-anchor" href="#Automatic-GPU-choice-with-gpu-and-gpu_device">Automatic GPU choice with <code>gpu</code> and <code>gpu_device</code></a><a id="Automatic-GPU-choice-with-gpu-and-gpu_device-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-GPU-choice-with-gpu-and-gpu_device" title="Permalink"></a></h2><p>Flux also provides a more automatic way of choosing which GPU (or none) to use. This is the function <code>gpu</code>:</p><ul><li>By default it does nothing.</li><li>If the package CUDA is loaded, and <code>CUDA.functional() === true</code>, then it behaves like <code>cu</code>.</li><li>If the package AMDGPU is loaded,  and <code>AMDGPU.functional() === true</code>, then it behaves like <code>roc</code>.</li><li>If the package Metal is loaded, and <code>Metal.functional() === true</code>, then it behaves like <code>mtl</code>.</li><li>If two differnet GPU packages are loaded, the first one takes priority.</li></ul><p>For the most part, this means that a script which says <code>model |&gt; gpu</code> and <code>data |&gt; gpu</code> will just work. It should always run, and if a GPU package is loaded (and finds the correct hardware) then that will be used.</p><p>The function <code>gpu</code> uses a lower-level function called <a href="../../reference/data/mldatadevices/#MLDataDevices.gpu_device"><code>gpu_device</code></a> from MLDataDevices.jl, which checks what to do and then returns some device object. In fact, the entire implementation is just this:</p><pre><code class="language-julia hljs">gpu(x) = gpu_device()(x)
cpu(x) = cpu_device()(x)</code></pre><p>Automatic backend selection through <code>gpu</code> is not type-stable. That doesn&#39;t matter if you do it once, or once per large batch – it costs a few microseconds. But it might matter if you do it within some loop.</p><p>To avoid this, you can first obtain a &quot;device object&quot; with <code>device = gpu_device()</code>, once, and then use this as the function to transfer data. Something like this:</p><pre><code class="language-julia hljs">to_device = gpu_device()
gpu_model = model |&gt; to_device

for epoch in 1:num_epochs
    for (x, y) in dataloader
        x_gpu, y_gpu = (x, y) |&gt; to_device
        # training code...</code></pre><p>Finally, setting a backend prefence with <a href="../../reference/data/mldatadevices/#MLDataDevices.gpu_backend!"><code>gpu_backend!</code></a> gives type stability to the whole pipeline.</p><h2 id="Transferring-Training-Data"><a class="docs-heading-anchor" href="#Transferring-Training-Data">Transferring Training Data</a><a id="Transferring-Training-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Transferring-Training-Data" title="Permalink"></a></h2><p>In order to train the model using the GPU both model and the training data have to be transferred to GPU memory. Moving the data can be done in two different ways:</p><ol><li><p>Iterating over the batches in a <a href="../../reference/data/mlutils/#DataLoader"><code>DataLoader</code></a> object transferring each one of the training batches at a time to the GPU. This is recommended for large datasets. Done by hand, it might look like this:</p><pre><code class="language-julia hljs">train_loader = Flux.DataLoader((X, Y), batchsize=64, shuffle=true)
# ... model definition, optimiser setup
for epoch in 1:epochs
    for (x_cpu, y_cpu) in train_loader
        x = gpu(x_cpu)
        y = gpu(y_cpu)
        grads = gradient(m -&gt; loss(m, x, y), model)
        Flux.update!(opt_state, model, grads[1])
    end
end</code></pre><p>Rather than write this out every time, you can just call <code>gpu(::DataLoader)</code>:</p><pre><code class="language-julia hljs">gpu_train_loader = Flux.DataLoader((X, Y), batchsize=64, shuffle=true) |&gt; gpu
# ... model definition, optimiser setup
for epoch in 1:epochs
    for (x, y) in gpu_train_loader
        grads = gradient(m -&gt; loss(m, x, y), model)
        Flux.update!(opt_state, model, grads[1])
    end
end</code></pre><p>This is equivalent to <code>DataLoader(MLUtils.mapobs(gpu, (X, Y)); keywords...)</code>. Something similar can also be done with <a href="https://cuda.juliagpu.org/stable/usage/memory/#Batching-iterator"><code>CUDA.CuIterator</code></a>, <code>gpu_train_loader = CUDA.CuIterator(train_loader)</code>. However, this only works with a limited number of data types: <code>first(train_loader)</code> should be a tuple (or <code>NamedTuple</code>) of arrays.</p></li><li><p>Transferring all training data to the GPU at once before creating the <code>DataLoader</code>. This is usually performed for smaller datasets which are sure to fit in the available GPU memory.</p><pre><code class="language-julia hljs">gpu_train_loader = Flux.DataLoader((X, Y) |&gt; gpu, batchsize = 32)
# ...
for epoch in 1:epochs
    for (x, y) in gpu_train_loader
        # ...</code></pre><p>Here <code>(X, Y) |&gt; gpu</code> applies <a href="../../reference/models/functors/#Flux.gpu-Tuple{Any}"><code>gpu</code></a> to both arrays, as it recurses into structures.</p></li></ol><h2 id="Saving-GPU-Trained-Models"><a class="docs-heading-anchor" href="#Saving-GPU-Trained-Models">Saving GPU-Trained Models</a><a id="Saving-GPU-Trained-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-GPU-Trained-Models" title="Permalink"></a></h2><p>After the training process is done, we must always transfer the trained model back to the CPU memory before serializing or saving to disk. This can be done with <code>cpu</code>:</p><pre><code class="language-julia hljs">model = cpu(model) # or model = model |&gt; cpu</code></pre><p>and then</p><pre><code class="language-julia hljs">using BSON
# ...
BSON.@save &quot;./path/to/trained_model.bson&quot; model

# in this approach the cpu-transferred model (referenced by the variable `model`)
# only exists inside the `let` statement
let model = cpu(model)
   # ...
   BSON.@save &quot;./path/to/trained_model.bson&quot; model
end

# is equivalent to the above, but uses `key=value` storing directive from BSON.jl
BSON.@save &quot;./path/to/trained_model.bson&quot; model = cpu(model)</code></pre><p>The reason behind this is that models trained in the GPU but not transferred to the CPU memory scope will expect <code>CuArray</code>s as input. In other words, Flux models expect input data coming from the same kind device in which they were trained on.</p><p>In controlled scenarios in which the data fed to the loaded models is guaranteed to be in the GPU there&#39;s no need to transfer them back to CPU memory scope, however in production environments, where artifacts are shared among different processes, equipments or configurations, there is no guarantee that the CUDA.jl package will be available for the process performing inference on the model loaded from the disk.</p><h2 id="Disabling-CUDA-or-choosing-which-GPUs-are-visible-to-Flux"><a class="docs-heading-anchor" href="#Disabling-CUDA-or-choosing-which-GPUs-are-visible-to-Flux">Disabling CUDA or choosing which GPUs are visible to Flux</a><a id="Disabling-CUDA-or-choosing-which-GPUs-are-visible-to-Flux-1"></a><a class="docs-heading-anchor-permalink" href="#Disabling-CUDA-or-choosing-which-GPUs-are-visible-to-Flux" title="Permalink"></a></h2><p>Sometimes it is required to control which GPUs are visible to <code>julia</code> on a system with multiple GPUs or disable GPUs entirely. This can be achieved with an environment variable <code>CUDA_VISIBLE_DEVICES</code>.</p><p>To disable all devices:</p><pre><code class="nohighlight hljs">$ export CUDA_VISIBLE_DEVICES=&#39;-1&#39;</code></pre><p>To select specific devices by device id:</p><pre><code class="nohighlight hljs">$ export CUDA_VISIBLE_DEVICES=&#39;0,1&#39;</code></pre><p>More information for conditional use of GPUs in CUDA.jl can be found in its <a href="https://cuda.juliagpu.org/stable/installation/conditional/#Conditional-use">documentation</a>, and information about the specific use of the variable is described in the <a href="https://developer.nvidia.com/blog/cuda-pro-tip-control-gpu-visibility-cuda_visible_devices/">Nvidia CUDA blog post</a>.</p><h2 id="Data-movement-across-GPU-devices"><a class="docs-heading-anchor" href="#Data-movement-across-GPU-devices">Data movement across GPU devices</a><a id="Data-movement-across-GPU-devices-1"></a><a class="docs-heading-anchor-permalink" href="#Data-movement-across-GPU-devices" title="Permalink"></a></h2><p>Flux also supports getting handles to specific GPU devices, and transferring models from one GPU device to another GPU device from the same backend. Let&#39;s try it out for NVIDIA GPUs. First, we list all the available devices:</p><pre><code class="language-julia-repl hljs">julia&gt; using Flux, CUDA;

julia&gt; CUDA.devices()
CUDA.DeviceIterator() for 3 devices:
0. NVIDIA TITAN RTX
1. NVIDIA TITAN RTX
2. NVIDIA TITAN RTX</code></pre><p>Then, let&#39;s select the device with id <code>0</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; device0 = gpu_device(1)
(::CUDADevice{CuDevice}) (generic function with 4 methods)

julia&gt; device0.device
CuDevice(0): NVIDIA TITAN RTX</code></pre><p>Notice that indexing starts from <code>0</code> in the <code>CUDA.devices()</code> output, but <code>gpu_device!</code> expects the device id starting from <code>1</code>.</p><p>Then, let&#39;s move a simple dense layer to the GPU represented by <code>device0</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; dense_model = Dense(2 =&gt; 3)
Dense(2 =&gt; 3)       # 9 parameters

julia&gt; dense_model = dense_model |&gt; device0;

julia&gt; dense_model.weight
3×2 CuArray{Float32, 2, CUDA.DeviceMemory}:
 -0.142062  -0.131455
 -0.828134  -1.06552
  0.608595  -1.05375

julia&gt; CUDA.device(dense_model.weight)      # check the GPU to which dense_model is attached
CuDevice(0): NVIDIA TITAN RTX</code></pre><p>Next, we&#39;ll get a handle to the device with id <code>1</code>, and move <code>dense_model</code> to that device:</p><pre><code class="language-julia-repl hljs">julia&gt; device1 = gpu_device(2)
(::CUDADevice{CuDevice}) (generic function with 4 methods)

julia&gt; dense_model = dense_model |&gt; device1;    # don&#39;t directly print the model; see warning below

julia&gt; CUDA.device(dense_model.weight)
CuDevice(1): NVIDIA TITAN RTX</code></pre><p>Due to a limitation in <code>Metal.jl</code>, currently this kind of data movement across devices is only supported for <code>CUDA</code> and <code>AMDGPU</code> backends.</p><h2 id="Distributed-data-parallel-training"><a class="docs-heading-anchor" href="#Distributed-data-parallel-training">Distributed data parallel training</a><a id="Distributed-data-parallel-training-1"></a><a class="docs-heading-anchor-permalink" href="#Distributed-data-parallel-training" title="Permalink"></a></h2><div class="admonition is-danger"><header class="admonition-header">Experimental</header><div class="admonition-body"><p>Distributed support is experimental and could change in the future.</p></div></div><p>Flux supports now distributed data parallel training with <code>DistributedUtils</code> module. If you want to run your code on multiple GPUs, you have to install <code>MPI.jl</code> (see <a href="https://juliaparallel.org/MPI.jl/stable/usage/">docs</a> for more info).</p><pre><code class="language-julia-repl hljs">julia&gt; using MPI

julia&gt; MPI.install_mpiexecjl()</code></pre><p>Now you can run your code with <code>mpiexecjl --project=. -n &lt;np&gt; julia &lt;filename&gt;.jl</code> from CLI.</p><p>You can use either the <code>MPIBackend</code> or <code>NCCLBackend</code>, the latter only if also <code>NCCL.jl</code> is loaded. First, initialize a backend with <code>DistributedUtils.initialize</code>, e.g.</p><pre><code class="language-julia-repl hljs">julia&gt; using Flux, MPI, NCCL, CUDA

julia&gt; CUDA.allowscalar(false)

julia&gt; DistributedUtils.initialize(NCCLBackend)

julia&gt; backend = DistributedUtils.get_distributed_backend(NCCLBackend)
NCCLBackend{Communicator, MPIBackend{MPI.Comm}}(Communicator(Ptr{NCCL.LibNCCL.ncclComm} @0x000000000607a660), MPIBackend{MPI.Comm}(MPI.Comm(1140850688)))</code></pre><p>Pass your model, as well as any data to GPU device.</p><pre><code class="language-julia-repl hljs">julia&gt; model = Chain(Dense(1 =&gt; 256, tanh), Dense(256 =&gt; 1)) |&gt; gpu
Chain(
  Dense(1 =&gt; 256, tanh),                # 512 parameters
  Dense(256 =&gt; 1),                      # 257 parameters
)                   # Total: 4 arrays, 769 parameters, 744 bytes.

julia&gt; x = rand(Float32, 1, 16) |&gt; gpu
1×16 CUDA.CuArray{Float32, 2, CUDA.DeviceMemory}:
 0.239324  0.331029  0.924996  0.55593  0.853093  0.874513  0.810269  0.935858  0.477176  0.564591  0.678907  0.729682  0.96809  0.115833  0.66191  0.75822

julia&gt; y = x .^ 3
1×16 CUDA.CuArray{Float32, 2, CUDA.DeviceMemory}:
 0.0137076  0.0362744  0.791443  0.171815  0.620854  0.668804  0.53197  0.819654  0.108651  0.179971  0.312918  0.388508  0.907292  0.00155418  0.29  0.435899</code></pre><p>In this case, we are training on a total of <code>16 * number of processes</code> samples. You can also use <code>DistributedUtils.DistributedDataContainer</code> to split the data uniformly across processes (or do it manually).</p><pre><code class="language-julia-repl hljs">julia&gt; data = DistributedUtils.DistributedDataContainer(backend, x)
Flux.DistributedUtils.DistributedDataContainer(Float32[0.23932439 0.33102947 … 0.66191036 0.75822026], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])</code></pre><p>You have to wrap your model in <code>DistributedUtils.FluxDistributedModel</code> and synchronize it (broadcast accross all processes):</p><pre><code class="language-julia-repl hljs">julia&gt; model = DistributedUtils.synchronize!!(backend, DistributedUtils.FluxDistributedModel(model); root=0)
Chain(
  Dense(1 =&gt; 256, tanh),                # 512 parameters

  Dense(256 =&gt; 1),                      # 257 parameters
)                   # Total: 4 arrays, 769 parameters, 744 bytes.</code></pre><p>Time to set up an optimizer by using <code>DistributedUtils.DistributedOptimizer</code> and synchronize it as well.</p><pre><code class="language-julia-repl hljs">julia&gt; using Optimisers

julia&gt; opt = DistributedUtils.DistributedOptimizer(backend, Optimisers.Adam(0.001f0))
DistributedOptimizer{MPIBackend{Comm}}(MPIBackend{Comm}(Comm(1140850688)), Adam(0.001, (0.9, 0.999), 1.0e-8))

julia&gt; st_opt = Optimisers.setup(opt, model)
(layers = ((weight = Leaf(DistributedOptimizer{MPIBackend{Comm}}(MPIBackend{Comm}(Comm(1140850688)), Adam(0.001, (0.9, 0.999), 1.0e-8)), (Float32[0.0; 0.0; … ; 0.0; 0.0;;], Float32[0.0; 0.0; … ; 0.0; 0.0;;], (0.9, 0.999))), bias = Leaf(DistributedOptimizer{MPIBackend{Comm}}(MPIBackend{Comm}(Comm(1140850688)), Adam(0.001, (0.9, 0.999), 1.0e-8)), (Float32[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Float32[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], (0.9, 0.999))), σ = ()), (weight = Leaf(DistributedOptimizer{MPIBackend{Comm}}(MPIBackend{Comm}(Comm(1140850688)), Adam(0.001, (0.9, 0.999), 1.0e-8)), (Float32[0.0 0.0 … 0.0 0.0], Float32[0.0 0.0 … 0.0 0.0], (0.9, 0.999))), bias = Leaf(DistributedOptimizer{MPIBackend{Comm}}(MPIBackend{Comm}(Comm(1140850688)), Adam(0.001, (0.9, 0.999), 1.0e-8)), (Float32[0.0], Float32[0.0], (0.9, 0.999))), σ = ())),)

julia&gt; st_opt = DistributedUtils.synchronize!!(backend, st_opt; root=0)
(layers = ((weight = Leaf(DistributedOptimizer{MPIBackend{Comm}}(MPIBackend{Comm}(Comm(1140850688)), Adam(0.001, (0.9, 0.999), 1.0e-8)), (Float32[0.0; 0.0; … ; 0.0; 0.0;;], Float32[0.0; 0.0; … ; 0.0; 0.0;;], (0.9, 0.999))), bias = Leaf(DistributedOptimizer{MPIBackend{Comm}}(MPIBackend{Comm}(Comm(1140850688)), Adam(0.001, (0.9, 0.999), 1.0e-8)), (Float32[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Float32[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], (0.9, 0.999))), σ = ()), (weight = Leaf(DistributedOptimizer{MPIBackend{Comm}}(MPIBackend{Comm}(Comm(1140850688)), Adam(0.001, (0.9, 0.999), 1.0e-8)), (Float32[0.0 0.0 … 0.0 0.0], Float32[0.0 0.0 … 0.0 0.0], (0.9, 0.999))), bias = Leaf(DistributedOptimizer{MPIBackend{Comm}}(MPIBackend{Comm}(Comm(1140850688)), Adam(0.001, (0.9, 0.999), 1.0e-8)), (Float32[0.0], Float32[0.0], (0.9, 0.999))), σ = ())),)</code></pre><p>Now you can define loss and train the model.</p><pre><code class="language-julia-repl hljs">julia&gt; loss(model) = mean((model(x) .- y).^2)
loss (generic function with 1 method)

julia&gt; for epoch in 1:100
           global model, st_opt
           l, grad = Zygote.withgradient(loss, model)
           println(&quot;Epoch $epoch: Loss $l&quot;)
           st_opt, model = Optimisers.update(st_opt, model, grad[1])
         end
Epoch 1: Loss 0.011638729
Epoch 2: Loss 0.0116432225
Epoch 3: Loss 0.012763695
...</code></pre><p>Remember that in order to run it on multiple GPUs you have to run from CLI <code>mpiexecjl --project=. -n &lt;np&gt; julia &lt;filename&gt;.jl</code>, where  <code>&lt;np&gt;</code> is the number of processes that you want to use. The number of processes usually corresponds to the number of gpus.</p><p>By default <code>MPI.jl</code> MPI installation is CUDA-unaware so if you want to run it in CUDA-aware mode, read more <a href="https://juliaparallel.org/MPI.jl/stable/usage/#CUDA-aware-MPI-support">here</a> on custom installation and rebuilding <code>MPI.jl</code>. Then test if your MPI is CUDA-aware by</p><pre><code class="language-julia-repl hljs">julia&gt; import Pkg
julia&gt; Pkg.test(&quot;MPI&quot;; test_args=[&quot;--backend=CUDA&quot;])</code></pre><p>If it is, set your local preference as below</p><pre><code class="language-julia-repl hljs">julia&gt; using Preferences
julia&gt; set_preferences!(&quot;Flux&quot;, &quot;FluxDistributedMPICUDAAware&quot; =&gt; true)</code></pre><div class="admonition is-warning"><header class="admonition-header">Known shortcomings</header><div class="admonition-body"><p>We don&#39;t run CUDA-aware tests so you&#39;re running it at own risk.</p></div></div><h2 id="Checking-GPU-Availability"><a class="docs-heading-anchor" href="#Checking-GPU-Availability">Checking GPU Availability</a><a id="Checking-GPU-Availability-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-GPU-Availability" title="Permalink"></a></h2><p>By default, Flux will run the checks on your system to see if it can support GPU functionality. You can check if Flux identified a valid GPU setup by typing the following:</p><pre><code class="language-julia-repl hljs">julia&gt; using CUDA

julia&gt; CUDA.functional()
true</code></pre><p>For AMD GPU:</p><pre><code class="language-julia-repl hljs">julia&gt; using AMDGPU

julia&gt; AMDGPU.functional()
true

julia&gt; AMDGPU.functional(:MIOpen)
true</code></pre><p>For Metal GPU:</p><pre><code class="language-julia-repl hljs">julia&gt; using Metal

julia&gt; Metal.functional()
true</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../models/recurrence/">« Recurrence</a><a class="docs-footer-nextpage" href="../saving/">Saving &amp; Loading »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 5 December 2024 06:00">Thursday 5 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
