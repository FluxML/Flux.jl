<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model Reference · Flux</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-36890222-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/flux.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Flux</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Building Models</span><ul><li><a class="tocitem" href="../basics/">Basics</a></li><li><a class="tocitem" href="../recurrence/">Recurrence</a></li><li class="is-active"><a class="tocitem" href>Model Reference</a><ul class="internal"><li><a class="tocitem" href="#Convolution-and-Pooling-Layers"><span>Convolution and Pooling Layers</span></a></li><li><a class="tocitem" href="#Recurrent-Layers"><span>Recurrent Layers</span></a></li><li><a class="tocitem" href="#Other-General-Purpose-Layers"><span>Other General Purpose Layers</span></a></li><li><a class="tocitem" href="#Normalisation-and-Regularisation"><span>Normalisation &amp; Regularisation</span></a></li></ul></li><li><a class="tocitem" href="../losses/">Loss Functions</a></li><li><a class="tocitem" href="../regularisation/">Regularisation</a></li><li><a class="tocitem" href="../advanced/">Advanced Model Building</a></li><li><a class="tocitem" href="../nnlib/">NNlib</a></li></ul></li><li><span class="tocitem">Handling Data</span><ul><li><a class="tocitem" href="../../data/onehot/">One-Hot Encoding</a></li><li><a class="tocitem" href="../../data/dataloader/">DataLoader</a></li></ul></li><li><span class="tocitem">Training Models</span><ul><li><a class="tocitem" href="../../training/optimisers/">Optimisers</a></li><li><a class="tocitem" href="../../training/training/">Training</a></li></ul></li><li><a class="tocitem" href="../../gpu/">GPU Support</a></li><li><a class="tocitem" href="../../saving/">Saving &amp; Loading</a></li><li><a class="tocitem" href="../../ecosystem/">The Julia Ecosystem</a></li><li><a class="tocitem" href="../../utilities/">Utility Functions</a></li><li><a class="tocitem" href="../../performance/">Performance Tips</a></li><li><a class="tocitem" href="../../datasets/">Datasets</a></li><li><a class="tocitem" href="../../community/">Community</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Building Models</a></li><li class="is-active"><a href>Model Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FluxML/Flux.jl/blob/master/docs/src/models/layers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Basic-Layers"><a class="docs-heading-anchor" href="#Basic-Layers">Basic Layers</a><a id="Basic-Layers-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Layers" title="Permalink"></a></h1><p>These core layers form the foundation of almost all neural networks.</p><article class="docstring"><header><a class="docstring-binding" id="Flux.Chain" href="#Flux.Chain"><code>Flux.Chain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Chain(layers...)</code></pre><p>Chain multiple layers / functions together, so that they are called in sequence on a given input.</p><p><code>Chain</code> also supports indexing and slicing, e.g. <code>m[2]</code> or <code>m[1:end-1]</code>. <code>m[1:3](x)</code> will calculate the output of the first three layers.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; m = Chain(x -&gt; x^2, x -&gt; x+1);

julia&gt; m(5) == 26
true

julia&gt; m = Chain(Dense(10, 5), Dense(5, 2));

julia&gt; x = rand(10);

julia&gt; m(x) == m[2](m[1](x))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/basic.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.Dense" href="#Flux.Dense"><code>Flux.Dense</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Dense(in, out, σ=identity; initW=glorot_uniform, initb=zeros, bias=true)
Dense(W, b, σ=identity)</code></pre><p>Create a traditional <code>Dense</code> layer with in×out weight matrix <code>W</code> and  bias vector  <code>b</code> of length <code>out</code>. The forward pass is given by:</p><pre><code class="language-none">y = σ.(W * x .+ b)</code></pre><p>The input <code>x</code> must be a vector of length <code>in</code>, a batch of vectors represented as an <code>in × N</code> matrix, or a higher order tensor where all dimensions after the first one will be treated as batch dimensions.</p><p>The out <code>y</code> will be a vector  of length <code>out</code> or a batch whose first dimension is <code>out</code> and the remaining dimensions are the same as in the input.</p><p>Setting <code>bias</code> to <code>false</code> will switch the bias  off for the layer.</p><p><code>initW</code> and <code>initb</code> are callables used to initialize weights and biases respectively, through the calls <code>initW(out, in)</code> and <code>initb(out)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dense(5, 2)
Dense(5, 2)

julia&gt; d(rand(Float32, 5))
2-element Array{Float32,1}:
 -0.16210233
  0.123119034

julia&gt; d = Dense(5, 2; bias=false)
Dense(5, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/basic.jl#L71-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.Diagonal" href="#Flux.Diagonal"><code>Flux.Diagonal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Diagonal(in::Integer)</code></pre><p>Create an element-wise linear transformation layer with learnable vectors <code>α</code> and <code>β</code>:</p><pre><code class="language-none">y = α .* x .+ β</code></pre><p>The input <code>x</code> must be a array where <code>size(x, 1) == in</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/basic.jl#L145-L154">source</a></section></article><h2 id="Convolution-and-Pooling-Layers"><a class="docs-heading-anchor" href="#Convolution-and-Pooling-Layers">Convolution and Pooling Layers</a><a id="Convolution-and-Pooling-Layers-1"></a><a class="docs-heading-anchor-permalink" href="#Convolution-and-Pooling-Layers" title="Permalink"></a></h2><p>These layers are used to build convolutional neural networks (CNNs).</p><article class="docstring"><header><a class="docstring-binding" id="Flux.Conv" href="#Flux.Conv"><code>Flux.Conv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Conv(filter, in =&gt; out, σ=identity; stride=1, pad=0, dilation=1)</code></pre><p>Standard convolutional layer. <code>filter</code> is a tuple of integers specifying the size of the convolutional kernel; <code>in</code> and <code>out</code> specify the number of input and output channels.</p><p>Image data should be stored in WHCN order (width, height, channels, batch). In other words, a 100×100 RGB image would be a <code>100×100×3×1</code> array, and a batch of 50 would be a <code>100×100×3×50</code> array. This has <code>N=2</code> spatial dimensions, and needs a kernel size like <code>(5,5)</code>, a 2-tuple of integers.</p><p>For <code>N</code> spatial dimensions, this layer expects as input an array with <code>ndims(x) == N+2</code>, where <code>size(x,N+1) == in</code> is the number of channels. Then:</p><ul><li><code>filter</code> should be a tuple of <code>N</code> integers.</li><li>Keywords <code>stride</code> and <code>dilation</code> should each be either single integer, or a tuple with <code>N</code> integers.</li><li>Keyword <code>pad</code> can be:<ul><li>a single integer for equal padding all around,</li><li>a tuple of <code>N</code> integers, to apply the same padding at begin/end of each spatial dimension,</li><li>a tuple of <code>2*N</code> integers, for asymmetric padding, or</li><li>the singleton <code>SamePad()</code>, to calculate padding such that <code>size(output,d) == size(x,d) / stride</code> (possibly rounded) for each spatial dimension.</li></ul></li></ul><p>Accepts two keywords to control its parameters:</p><ul><li>Initial weights are generated by the function <code>init = glorot_uniform</code>.</li><li>Initial bias is zero by default, this can be disabled entirely with <code>bias = false</code>, or another vector provided as <code>bias = randn(Float32, out)</code>.</li></ul><p>See also <a href="#Flux.ConvTranspose"><code>ConvTranspose</code></a>, <a href="#Flux.DepthwiseConv"><code>DepthwiseConv</code></a>, <a href="#Flux.CrossCor"><code>CrossCor</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50); # a batch of images

julia&gt; lay = Conv((5,5), 3 =&gt; 7, relu; bias=false)
Conv((5, 5), 3=&gt;7, relu)

julia&gt; lay(xs) |&gt; size
(96, 96, 7, 50)

julia&gt; Conv((5,5), 3 =&gt; 7; stride=2)(xs) |&gt; size
(48, 48, 7, 50)

julia&gt; Conv((5,5), 3 =&gt; 7; stride=2, pad=SamePad())(xs) |&gt; size
(50, 50, 7, 50)

julia&gt; Conv((1,1), 3 =&gt; 7; pad=(20,10,0,0))(xs) |&gt; size
(130, 100, 7, 50)

julia&gt; Conv((5,5), 3 =&gt; 7; stride=2, dilation=4)(xs) |&gt; size
(42, 42, 7, 50)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/conv.jl#L32-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.AdaptiveMaxPool" href="#Flux.AdaptiveMaxPool"><code>Flux.AdaptiveMaxPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AdaptiveMaxPool(out::NTuple)</code></pre><p>Adaptive max pooling layer. Calculates the necessary window size such that its output has <code>size(y)[1:N] == out</code>.</p><p>Expects as input an array with <code>ndims(x) == N+2</code>, i.e. channel and batch dimensions, after the <code>N</code> feature dimensions, where <code>N = length(out)</code>.</p><p>See also <a href="#Flux.MaxPool"><code>MaxPool</code></a>, <a href="#Flux.AdaptiveMeanPool"><code>AdaptiveMeanPool</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50);  # batch of 50 RGB images

julia&gt; AdaptiveMaxPool((25, 25))(xs) |&gt; size
(25, 25, 3, 50)

julia&gt; MaxPool((4,4))(xs) ≈ AdaptiveMaxPool((25, 25))(xs)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/conv.jl#L502-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.MaxPool" href="#Flux.MaxPool"><code>Flux.MaxPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MaxPool(window::NTuple; pad=0, stride=window)</code></pre><p>Max pooling layer, which replaces all pixels in a block of size <code>window</code> with one.</p><p>Expects as input an array with <code>ndims(x) == N+2</code>, i.e. channel and batch dimensions, after the <code>N</code> feature dimensions, where <code>N = length(window)</code>.</p><p>By default the window size is also the stride in each dimension. The keyword <code>pad</code> accepts the same options as for the <code>Conv</code> layer, including <code>SamePad()</code>.</p><p>See also <a href="#Flux.Conv"><code>Conv</code></a>, <a href="#Flux.MeanPool"><code>MeanPool</code></a>, <a href="#Flux.AdaptiveMaxPool"><code>AdaptiveMaxPool</code></a>, <a href="#Flux.GlobalMaxPool"><code>GlobalMaxPool</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50);  # batch of 50 RGB images

julia&gt; m = Chain(Conv((5, 5), 3=&gt;7, pad=SamePad()), MaxPool((5, 5), pad=SamePad()))
Chain(Conv((5, 5), 3=&gt;7), MaxPool((5, 5), pad=2))

julia&gt; m[1](xs) |&gt; size
(100, 100, 7, 50)

julia&gt; m(xs) |&gt; size
(20, 20, 7, 50)

julia&gt; lay = MaxPool((5,), pad=2, stride=(3,))  # one-dimensional window
MaxPool((5,), pad=2, stride=3)

julia&gt; lay(rand(Float32, 100, 7, 50)) |&gt; size
(34, 7, 50)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/conv.jl#L659-L694">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.GlobalMaxPool" href="#Flux.GlobalMaxPool"><code>Flux.GlobalMaxPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GlobalMaxPool()</code></pre><p>Global max pooling layer.</p><p>Transforms (w,h,c,b)-shaped input into (1,1,c,b)-shaped output, by performing max pooling on the complete (w,h)-shaped feature maps.</p><p>See also <a href="#Flux.MaxPool"><code>MaxPool</code></a>, <a href="#Flux.GlobalMeanPool"><code>GlobalMeanPool</code></a>.</p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50);

julia&gt; m = Chain(Conv((3,3), 3=&gt;7), GlobalMaxPool())
Chain(Conv((3, 3), 3=&gt;7), GlobalMaxPool())

julia&gt; m(xs) |&gt; size
(1, 1, 7, 50)

julia&gt; GlobalMaxPool()(rand(3,5,7)) |&gt; size  # preserves 2 dimensions
(1, 5, 7)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/conv.jl#L584-L606">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.AdaptiveMeanPool" href="#Flux.AdaptiveMeanPool"><code>Flux.AdaptiveMeanPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AdaptiveMeanPool(out::NTuple)</code></pre><p>Adaptive mean pooling layer. Calculates the necessary window size such that its output has <code>size(y)[1:N] == out</code>.</p><p>Expects as input an array with <code>ndims(x) == N+2</code>, i.e. channel and batch dimensions, after the <code>N</code> feature dimensions, where <code>N = length(out)</code>.</p><p>See also <a href="#Flux.MaxPool"><code>MaxPool</code></a>, <a href="#Flux.AdaptiveMaxPool"><code>AdaptiveMaxPool</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50);  # batch of 50 RGB images

julia&gt; AdaptiveMeanPool((25, 25))(xs) |&gt; size
(25, 25, 3, 50)

julia&gt; MeanPool((4,4))(xs) ≈ AdaptiveMeanPool((25, 25))(xs)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/conv.jl#L543-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.MeanPool" href="#Flux.MeanPool"><code>Flux.MeanPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MeanPool(window::NTuple; pad=0, stride=window)</code></pre><p>Mean pooling layer, averaging all pixels in a block of size <code>window</code>.</p><p>Expects as input an array with <code>ndims(x) == N+2</code>, i.e. channel and batch dimensions, after the <code>N</code> feature dimensions, where <code>N = length(window)</code>.</p><p>By default the window size is also the stride in each dimension. The keyword <code>pad</code> accepts the same options as for the <code>Conv</code> layer, including <code>SamePad()</code>.</p><p>See also <a href="#Flux.Conv"><code>Conv</code></a>, <a href="#Flux.MaxPool"><code>MaxPool</code></a>, <a href="#Flux.AdaptiveMeanPool"><code>AdaptiveMeanPool</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50);

julia&gt; m = Chain(Conv((5,5), 3 =&gt; 7), MeanPool((5,5), pad=SamePad()))
Chain(Conv((5, 5), 3=&gt;7), MeanPool((5, 5), pad=2))

julia&gt; m[1](xs) |&gt; size
(96, 96, 7, 50)

julia&gt; m(xs) |&gt; size
(20, 20, 7, 50)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/conv.jl#L722-L750">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.GlobalMeanPool" href="#Flux.GlobalMeanPool"><code>Flux.GlobalMeanPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GlobalMeanPool()</code></pre><p>Global mean pooling layer.</p><p>Transforms (w,h,c,b)-shaped input into (1,1,c,b)-shaped output, by performing mean pooling on the complete (w,h)-shaped feature maps.</p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50);

julia&gt; m = Chain(Conv((3,3), 3=&gt;7), GlobalMeanPool())
Chain(Conv((3, 3), 3=&gt;7), GlobalMeanPool())

julia&gt; m(xs) |&gt; size
(1, 1, 7, 50)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/conv.jl#L624-L641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.DepthwiseConv" href="#Flux.DepthwiseConv"><code>Flux.DepthwiseConv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DepthwiseConv(filter, in=&gt;out, σ=identity; stride=1, pad=0, dilation=1)</code></pre><p>Depthwise convolutional layer. <code>filter</code> is a tuple of integers specifying the size of the convolutional kernel, while <code>in</code> and <code>out</code> specify the number of input and output channels.</p><p>Note that <code>out</code> must be an integer multiple of <code>in</code>.</p><p>Parameters are controlled by additional keywords, with defaults <code>init=glorot_uniform</code> and <code>bias=true</code>.</p><p>See also <a href="#Flux.Conv"><code>Conv</code></a> for more detailed description of keywords.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50);  # a batch of 50 RGB images

julia&gt; lay = DepthwiseConv((5,5), 3 =&gt; 6, relu; bias=false)
DepthwiseConv((5, 5), 3=&gt;6, relu)

julia&gt; lay(xs) |&gt; size
(96, 96, 6, 50)

julia&gt; DepthwiseConv((5,5), 3 =&gt; 9, stride=2, pad=2)(xs) |&gt; size
(50, 50, 9, 50)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/conv.jl#L301-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.ConvTranspose" href="#Flux.ConvTranspose"><code>Flux.ConvTranspose</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConvTranspose(filter, in =&gt; out, σ=identity; stride=1, pad=0, dilation=1)</code></pre><p>Standard convolutional transpose layer. <code>filter</code> is a tuple of integers specifying the size of the convolutional kernel, while <code>in</code> and <code>out</code> specify the number of input and output channels.</p><p>Note that <code>pad=SamePad()</code> here tries to ensure <code>size(output,d) == size(x,d) * stride</code>.</p><p>Parameters are controlled by additional keywords, with defaults <code>init=glorot_uniform</code> and <code>bias=true</code>.</p><p>See also <a href="#Flux.Conv"><code>Conv</code></a> for more detailed description of keywords.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50);  # a batch of 50 RGB images

julia&gt; lay = ConvTranspose((5,5), 3 =&gt; 7, relu)
ConvTranspose((5, 5), 3=&gt;7, relu)

julia&gt; lay(xs) |&gt; size
(104, 104, 7, 50)

julia&gt; ConvTranspose((5,5), 3=&gt;7, stride=2)(xs) |&gt; size
(203, 203, 7, 50)

julia&gt; ConvTranspose((5,5), 3=&gt;7, stride=3, pad=SamePad())(xs) |&gt; size
(300, 300, 7, 50)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/conv.jl#L189-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.CrossCor" href="#Flux.CrossCor"><code>Flux.CrossCor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CrossCor(filter, in =&gt; out, σ=identity; stride=1, pad=0, dilation=1)</code></pre><p>Standard cross convolutional layer. <code>filter</code> is a tuple of integers specifying the size of the convolutional kernel; <code>in</code> and <code>out</code> specify the number of input and output channels.</p><p>Parameters are controlled by additional keywords, with defaults <code>init=glorot_uniform</code> and <code>bias=true</code>.</p><p>See also <a href="#Flux.Conv"><code>Conv</code></a> for more detailed description of keywords.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50);  # a batch of 50 RGB images

julia&gt; lay = CrossCor((5,5), 3 =&gt; 6, relu; bias=false)
CrossCor((5, 5), 3=&gt;6, relu)

julia&gt; lay(xs) |&gt; size
(96, 96, 6, 50)

julia&gt; CrossCor((5,5), 3=&gt;7, stride=3, pad=(2,0))(xs) |&gt; size
(34, 32, 7, 50)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/conv.jl#L409-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.SamePad" href="#Flux.SamePad"><code>Flux.SamePad</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SamePad()</code></pre><p>Passed as an option to convolutional layers (and friends), this causes the padding to be chosen such that the input and output sizes agree (on the first <code>N</code> dimensions, the kernel or window) when <code>stride==1</code>.</p><p>See also <a href="#Flux.Conv"><code>Conv</code></a>, <a href="#Flux.MaxPool"><code>MaxPool</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/conv.jl#L9-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.flatten" href="#Flux.flatten"><code>Flux.flatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">flatten(x::AbstractArray)</code></pre><p>Reshape arbitrarly-shaped input into a matrix-shaped output preserving the last dimension size. Equivalent to <code>reshape(x, :, size(x)[end])</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/stateless.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.convfilter" href="#Flux.convfilter"><code>Flux.convfilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">convfilter(filter::Tuple, in=&gt;out)</code></pre><p>Constructs a standard convolutional weight matrix with given <code>filter</code> and channels from <code>in</code> to <code>out</code>.</p><p>Accepts the keyword <code>init</code> (default: <code>glorot_uniform</code>) to control the sampling distribution.</p><p>See also: <a href="#Flux.depthwiseconvfilter"><code>depthwiseconvfilter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/conv.jl#L144-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.depthwiseconvfilter" href="#Flux.depthwiseconvfilter"><code>Flux.depthwiseconvfilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">depthwiseconvfilter(filter::Tuple, in=&gt;out)</code></pre><p>Constructs a depthwise convolutional weight array defined by <code>filter</code> and channels from <code>in</code> to <code>out</code>.</p><p>Accepts the keyword <code>init</code> (default: <code>glorot_uniform</code>) to control the sampling distribution.</p><p>See also: <a href="#Flux.convfilter"><code>convfilter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/conv.jl#L359-L369">source</a></section></article><h2 id="Recurrent-Layers"><a class="docs-heading-anchor" href="#Recurrent-Layers">Recurrent Layers</a><a id="Recurrent-Layers-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrent-Layers" title="Permalink"></a></h2><p>Much like the core layers above, but can be used to process sequence data (as well as other kinds of structured data).</p><article class="docstring"><header><a class="docstring-binding" id="Flux.RNN" href="#Flux.RNN"><code>Flux.RNN</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RNN(in::Integer, out::Integer, σ = tanh)</code></pre><p>The most basic recurrent layer; essentially acts as a <code>Dense</code> layer, but with the output fed back into the input each time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/recurrent.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.LSTM" href="#Flux.LSTM"><code>Flux.LSTM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">LSTM(in::Integer, out::Integer)</code></pre><p><a href="https://www.researchgate.net/publication/13853244_Long_Short-term_Memory">Long Short Term Memory</a> recurrent layer. Behaves like an RNN but generally exhibits a longer memory span over sequences.</p><p>See <a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">this article</a> for a good overview of the internals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/recurrent.jl#L149-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.GRU" href="#Flux.GRU"><code>Flux.GRU</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">GRU(in::Integer, out::Integer)</code></pre><p><a href="https://arxiv.org/abs/1406.1078">Gated Recurrent Unit</a> layer. Behaves like an RNN but generally exhibits a longer memory span over sequences.</p><p>See <a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">this article</a> for a good overview of the internals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/recurrent.jl#L203-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.Recur" href="#Flux.Recur"><code>Flux.Recur</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Recur(cell)</code></pre><p><code>Recur</code> takes a recurrent cell and makes it stateful, managing the hidden state in the background. <code>cell</code> should be a model of the form:</p><pre><code class="language-none">h, y = cell(h, x...)</code></pre><p>For example, here&#39;s a recurrent network that keeps a running total of its inputs:</p><pre><code class="language-julia">accum(h, x) = (h + x, x)
rnn = Flux.Recur(accum, 0)
rnn(2)      # 2
rnn(3)      # 3
rnn.state   # 5
rnn.(1:10)  # apply to a sequence
rnn.state   # 60</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/recurrent.jl#L8-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.reset!" href="#Flux.reset!"><code>Flux.reset!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reset!(rnn)</code></pre><p>Reset the hidden state of a recurrent layer back to its original value.</p><p>Assuming you have a <code>Recur</code> layer <code>rnn</code>, this is roughly equivalent to:</p><pre><code class="language-julia">rnn.state = hidden(rnn.cell)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/recurrent.jl#L43-L52">source</a></section></article><h2 id="Other-General-Purpose-Layers"><a class="docs-heading-anchor" href="#Other-General-Purpose-Layers">Other General Purpose Layers</a><a id="Other-General-Purpose-Layers-1"></a><a class="docs-heading-anchor-permalink" href="#Other-General-Purpose-Layers" title="Permalink"></a></h2><p>These are marginally more obscure than the Basic Layers. But in contrast to the layers described in the other sections are not readily grouped around a particular purpose (e.g. CNNs or RNNs).</p><article class="docstring"><header><a class="docstring-binding" id="Flux.Maxout" href="#Flux.Maxout"><code>Flux.Maxout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Maxout(over)</code></pre><p>The <a href="https://arxiv.org/abs/1302.4389">Maxout</a> layer has a number of internal layers which all receive the same input. It returns the elementwise maximum of the internal layers&#39; outputs.</p><p>Maxout over linear dense layers satisfies the univeral approximation theorem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/basic.jl#L174-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.SkipConnection" href="#Flux.SkipConnection"><code>Flux.SkipConnection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SkipConnection(layer, connection)</code></pre><p>Create a skip connection which consists of a layer or <code>Chain</code> of consecutive layers and a shortcut connection linking the block&#39;s input to the output through a user-supplied 2-argument callable. The first argument to the callable will be propagated through the given <code>layer</code> while the second is the unchanged, &quot;skipped&quot; input.</p><p>The simplest &quot;ResNet&quot;-type connection is just <code>SkipConnection(layer, +)</code>. Here is a more complicated example:</p><pre><code class="language-julia-repl">julia&gt; m = Conv((3,3), 4 =&gt; 7, pad=(1,1));

julia&gt; x = ones(Float32, 5, 5, 4, 10);

julia&gt; size(m(x)) == (5, 5, 7, 10)
true

julia&gt; sm = SkipConnection(m, (mx, x) -&gt; cat(mx, x, dims=3));

julia&gt; size(sm(x)) == (5, 5, 11, 10)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/basic.jl#L217-L241">source</a></section></article><h2 id="Normalisation-and-Regularisation"><a class="docs-heading-anchor" href="#Normalisation-and-Regularisation">Normalisation &amp; Regularisation</a><a id="Normalisation-and-Regularisation-1"></a><a class="docs-heading-anchor-permalink" href="#Normalisation-and-Regularisation" title="Permalink"></a></h2><p>These layers don&#39;t affect the structure of the network but may improve training times or reduce overfitting.</p><article class="docstring"><header><a class="docstring-binding" id="Flux.normalise" href="#Flux.normalise"><code>Flux.normalise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalise(x; dims=ndims(x), ϵ=1e-5)</code></pre><p>Normalise <code>x</code> to mean 0 and standard deviation 1 across the dimension(s) given by <code>dims</code>. Per default, <code>dims</code> is the last dimension.  <code>ϵ</code> is a small additive factor added to the denominator for numerical stability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/stateless.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.BatchNorm" href="#Flux.BatchNorm"><code>Flux.BatchNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BatchNorm(channels::Integer, σ = identity;
          initβ = zeros, initγ = ones,
          ϵ = 1e-8, momentum = .1)</code></pre><p><a href="https://arxiv.org/abs/1502.03167">Batch Normalization</a> layer. <code>channels</code> should be the size of the channel dimension in your data (see below).</p><p>Given an array with <code>N</code> dimensions, call the <code>N-1</code>th the channel dimension. (For a batch of feature vectors this is just the data dimension, for <code>WHCN</code> images it&#39;s the usual channel dimension.)</p><p><code>BatchNorm</code> computes the mean and variance for each each <code>W×H×1×N</code> slice and shifts them to have a new mean and variance (corresponding to the learnable, per-channel <code>bias</code> and <code>scale</code> parameters).</p><p>Use <a href="#Flux.testmode!"><code>testmode!</code></a> during inference.</p><p><strong>Examples</strong></p><pre><code class="language-julia">m = Chain(
  Dense(28^2, 64),
  BatchNorm(64, relu),
  Dense(64, 10),
  BatchNorm(10),
  softmax)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/normalise.jl#L138-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.dropout" href="#Flux.dropout"><code>Flux.dropout</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dropout(x, p; dims=:, active=true)</code></pre><p>The dropout function. If <code>active</code> is <code>true</code>, for each input, either sets that input to <code>0</code> (with probability <code>p</code>) or scales it by <code>1 / (1 - p)</code>. <code>dims</code> specifies the unbroadcasted dimensions, e.g. <code>dims=1</code> applies dropout along columns and <code>dims=2</code> along rows. This is used as a regularisation, i.e. it reduces overfitting during training.</p><p>If <code>active</code> is <code>false</code>, it just returns the input <code>x</code></p><p>Warning: when using this function, you have to manually manage the activation state. Usually in fact, dropout is used while training but is deactivated in the inference phase. This can be automatically managed using the <a href="#Flux.Dropout"><code>Dropout</code></a> layer instead of the <code>dropout</code> function.</p><p>The <a href="#Flux.Dropout"><code>Dropout</code></a> layer is what you should use in most scenarios.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/normalise.jl#L12-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.Dropout" href="#Flux.Dropout"><code>Flux.Dropout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Dropout(p, dims=:)</code></pre><p>Dropout layer. In the forward pass, apply the <a href="#Flux.dropout"><code>Flux.dropout</code></a> function on the input.</p><p>Does nothing to the input once <a href="#Flux.testmode!"><code>Flux.testmode!</code></a> is <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/normalise.jl#L49-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.AlphaDropout" href="#Flux.AlphaDropout"><code>Flux.AlphaDropout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AlphaDropout(p)</code></pre><p>A dropout layer. Used in <a href="https://arxiv.org/abs/1706.02515">Self-Normalizing Neural Networks</a>. The AlphaDropout layer ensures that mean and variance of activations remain the same as before.</p><p>Does nothing to the input once <a href="#Flux.testmode!"><code>testmode!</code></a> is true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/normalise.jl#L81-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.LayerNorm" href="#Flux.LayerNorm"><code>Flux.LayerNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LayerNorm(h::Integer)</code></pre><p>A <a href="https://arxiv.org/abs/1607.06450">normalisation layer</a> designed to be used with recurrent hidden states of size <code>h</code>. Normalises the mean and standard deviation of each input before applying a per-neuron gain/bias.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/normalise.jl#L116-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.InstanceNorm" href="#Flux.InstanceNorm"><code>Flux.InstanceNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InstanceNorm(channels::Integer, σ = identity;
             initβ = zeros, initγ = ones,
             ϵ = 1e-8, momentum = .1)</code></pre><p><a href="https://arxiv.org/abs/1607.08022">Instance Normalization</a> layer. <code>channels</code> should be the size of the channel dimension in your data (see below).</p><p>Given an array with <code>N</code> dimensions, call the <code>N-1</code>th the channel dimension. (For a batch of feature vectors this is just the data dimension, for <code>WHCN</code> images it&#39;s the usual channel dimension.)</p><p><code>InstanceNorm</code> computes the mean and variance for each each <code>W×H×1×1</code> slice and shifts them to have a new mean and variance (corresponding to the learnable, per-channel <code>bias</code> and <code>scale</code> parameters).</p><p>Use <a href="#Flux.testmode!"><code>testmode!</code></a> during inference.</p><p><strong>Examples</strong></p><pre><code class="language-julia">m = Chain(
  Dense(28^2, 64),
  InstanceNorm(64, relu),
  Dense(64, 10),
  InstanceNorm(10),
  softmax)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/normalise.jl#L240-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.GroupNorm" href="#Flux.GroupNorm"><code>Flux.GroupNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GroupNorm(chs::Integer, G::Integer, λ = identity;
          initβ = (i) -&gt; zeros(Float32, i), initγ = (i) -&gt; ones(Float32, i),
          ϵ = 1f-5, momentum = 0.1f0)</code></pre><p><a href="https://arxiv.org/abs/1803.08494">Group Normalization</a> layer. This layer can outperform Batch Normalization and Instance Normalization.</p><p><code>chs</code> is the number of channels, the channel dimension of your input. For an array of N dimensions, the <code>N-1</code>th index is the channel dimension.</p><p><code>G</code> is the number of groups along which the statistics are computed. The number of channels must be an integer multiple of the number of groups.</p><p>Use <a href="#Flux.testmode!"><code>testmode!</code></a> during inference.</p><p><strong>Examples</strong></p><pre><code class="language-julia">m = Chain(Conv((3,3), 1=&gt;32, leakyrelu;pad = 1),
          GroupNorm(32,16))
          # 32 channels, 16 groups (G = 16), thus 2 channels per group used</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/layers/normalise.jl#L323-L345">source</a></section></article><h3 id="Testmode"><a class="docs-heading-anchor" href="#Testmode">Testmode</a><a id="Testmode-1"></a><a class="docs-heading-anchor-permalink" href="#Testmode" title="Permalink"></a></h3><p>Many normalisation layers behave differently under training and inference (testing). By default, Flux will automatically determine when a layer evaluation is part of training or inference. Still, depending on your use case, it may be helpful to manually specify when these layers should be treated as being trained or not. For this, Flux provides <code>Flux.testmode!</code>. When called on a model (e.g. a layer or chain of layers), this function will place the model into the mode specified.</p><article class="docstring"><header><a class="docstring-binding" id="Flux.testmode!" href="#Flux.testmode!"><code>Flux.testmode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">testmode!(m, mode = true)</code></pre><p>Set a layer or model&#39;s test mode (see below). Using <code>:auto</code> mode will treat any gradient computation as training.</p><p><em>Note</em>: if you manually set a model into test mode, you need to manually place it back into train mode during training phase.</p><p>Possible values include:</p><ul><li><code>false</code> for training</li><li><code>true</code> for testing</li><li><code>:auto</code> or <code>nothing</code> for Flux to detect the mode automatically</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/functor.jl#L8-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flux.trainmode!" href="#Flux.trainmode!"><code>Flux.trainmode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trainmode!(m, mode = true)</code></pre><p>Set a layer of model&#39;s train mode (see below). Symmetric to <a href="#Flux.testmode!"><code>testmode!</code></a> (i.e. <code>trainmode!(m, mode) == testmode!(m, !mode)</code>).</p><p><em>Note</em>: if you manually set a model into train mode, you need to manually place it into test mode during testing phase.</p><p>Possible values include:</p><ul><li><code>true</code> for training</li><li><code>false</code> for testing</li><li><code>:auto</code> or <code>nothing</code> for Flux to detect the mode automatically</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Flux.jl/blob/af87bf030b546f5251fe154fc94f811f9e99fc51/src/functor.jl#L24-L37">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../recurrence/">« Recurrence</a><a class="docs-footer-nextpage" href="../losses/">Loss Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 31 December 2020 16:54">Thursday 31 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
