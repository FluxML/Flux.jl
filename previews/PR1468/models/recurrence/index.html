<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Recurrence · Flux</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-36890222-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/flux.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Flux</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Building Models</span><ul><li><a class="tocitem" href="../basics/">Basics</a></li><li class="is-active"><a class="tocitem" href>Recurrence</a><ul class="internal"><li><a class="tocitem" href="#Recurrent-cells"><span>Recurrent cells</span></a></li><li><a class="tocitem" href="#Stateful-Models"><span>Stateful Models</span></a></li><li><a class="tocitem" href="#Working-with-sequences"><span>Working with sequences</span></a></li></ul></li><li><a class="tocitem" href="../layers/">Model Reference</a></li><li><a class="tocitem" href="../losses/">Loss Functions</a></li><li><a class="tocitem" href="../regularisation/">Regularisation</a></li><li><a class="tocitem" href="../advanced/">Advanced Model Building</a></li><li><a class="tocitem" href="../nnlib/">NNlib</a></li></ul></li><li><span class="tocitem">Handling Data</span><ul><li><a class="tocitem" href="../../data/onehot/">One-Hot Encoding</a></li><li><a class="tocitem" href="../../data/dataloader/">DataLoader</a></li></ul></li><li><span class="tocitem">Training Models</span><ul><li><a class="tocitem" href="../../training/optimisers/">Optimisers</a></li><li><a class="tocitem" href="../../training/training/">Training</a></li></ul></li><li><a class="tocitem" href="../../gpu/">GPU Support</a></li><li><a class="tocitem" href="../../saving/">Saving &amp; Loading</a></li><li><a class="tocitem" href="../../ecosystem/">The Julia Ecosystem</a></li><li><a class="tocitem" href="../../utilities/">Utility Functions</a></li><li><a class="tocitem" href="../../performance/">Performance Tips</a></li><li><a class="tocitem" href="../../datasets/">Datasets</a></li><li><a class="tocitem" href="../../community/">Community</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Building Models</a></li><li class="is-active"><a href>Recurrence</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Recurrence</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FluxML/Flux.jl/blob/master/docs/src/models/recurrence.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Recurrent-Models"><a class="docs-heading-anchor" href="#Recurrent-Models">Recurrent Models</a><a id="Recurrent-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrent-Models" title="Permalink"></a></h1><h2 id="Recurrent-cells"><a class="docs-heading-anchor" href="#Recurrent-cells">Recurrent cells</a><a id="Recurrent-cells-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrent-cells" title="Permalink"></a></h2><p>To introduce Flux&#39;s recurrence functionalities, we will consider the following vanilla recurrent neural network structure:</p><p><img src="../../assets/rnn-basic.png" alt/></p><p>In the above, we have a sequence of length 3, where <code>x1</code> to <code>x3</code> represent the input at each step (could be a timestamp or a word in a sentence), and <code>y1</code> to <code>y3</code> are their respective outputs.</p><p>An aspect to recognize is that in such model, the recurrent cells <code>A</code> all refer to the same structure. What distinguishes it from a dense layer for example is that the cell A is fed, in addition to an input <code>x</code>, with information from the previous state of the model (hidden state denoted as <code>h1</code> &amp; <code>h2</code> in the diagram).</p><p>In the most basic RNN case, cell A could be defined by the following: </p><pre><code class="language-julia">Wxh = randn(5, 2)
Whh = randn(5, 5)
b   = randn(5)

function rnn(h, x)
  h = tanh.(Wxh * x .+ Whh * h .+ b)
  return h, h
end

x = rand(2) # dummy data
h = rand(5)  # initial hidden state

h, y = rnn(h, x)</code></pre><p>Notice how the above is essentially a <code>Dense</code> layer that acts on two inputs, <code>h</code> and <code>x</code>.</p><p>If you run the last line a few times, you&#39;ll notice the output <code>y</code> changing slightly even though the input <code>x</code> is the same.</p><p>There are various recurrent cells available in Flux, notably <code>RNNCell</code>, <code>LSTMCell</code> and <code>GRUCell</code>, which are documented in the <a href="../layers/">layer reference</a>. The hand-written example above can be replaced with:</p><pre><code class="language-julia">using Flux

rnn = Flux.RNNCell(2, 5)

x = rand(Float32, 2) # dummy data
h = rand(Float32, 5)  # initial hidden state

h, y = rnn(h, x)</code></pre><h2 id="Stateful-Models"><a class="docs-heading-anchor" href="#Stateful-Models">Stateful Models</a><a id="Stateful-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Stateful-Models" title="Permalink"></a></h2><p>For the most part, we don&#39;t want to manage hidden states ourselves, but to treat our models as being stateful. Flux provides the <code>Recur</code> wrapper to do this.</p><pre><code class="language-julia">x = rand(Float32, 2)
h = rand(Float32, 5)

m = Flux.Recur(rnn, h)

y = m(x)</code></pre><p>The <code>Recur</code> wrapper stores the state between runs in the <code>m.state</code> field.</p><p>If we use the <code>RNN(2, 5)</code> constructor – as opposed to <code>RNNCell</code> – you&#39;ll see that it&#39;s simply a wrapped cell.</p><pre><code class="language-julia">julia&gt; RNN(2, 5)
Recur(RNNCell(2, 5, tanh))</code></pre><p>Equivalent to the <code>RNN</code> stateful constructor, <code>LSTM</code> and <code>GRU</code> are also available. </p><p>Using these tools, we can now build the model is the above diagram with: </p><pre><code class="language-julia">m = Chain(RNN(2, 5), Dense(5, 1), x -&gt; reshape(x, :))</code></pre><h2 id="Working-with-sequences"><a class="docs-heading-anchor" href="#Working-with-sequences">Working with sequences</a><a id="Working-with-sequences-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-sequences" title="Permalink"></a></h2><p>Using the previously defined <code>m</code> recurrent model, we can the apply it to a single step from our sequence:</p><pre><code class="language-julia">x = rand(Float32, 2)
julia&gt; m(x)
1-element Array{Float32,1}:
 0.028398542</code></pre><p>The m(x) operation would be represented by <code>x1 -&gt; A -&gt; y1</code> in our diagram. If we perform this operation a second time, it will be equivalent to <code>x2 -&gt; A -&gt; y2</code> since the model <code>m</code> has stored the state resulting from the <code>x1</code> step:</p><pre><code class="language-julia">x = rand(Float32, 2)
julia&gt; m(x)
1-element Array{Float32,1}:
 0.07381232</code></pre><p>Now, instead of computing a single step at a time, we can get the full <code>y1</code> to <code>y3</code> sequence in a single pass by broadcasting the model on a sequence of data. </p><p>To do so, we&#39;ll need to structure the input data as a <code>Vector</code> of observations at each time step. This <code>Vector</code> will therefore be of length = <code>seq_length</code> and each of its elements will represent the input features for a given step. In our example, this translates into a <code>Vector</code> of length 3, where each element is a <code>Matrix</code> of size <code>(features, batch_size)</code>, or just a <code>Vector</code> of length <code>features</code> if dealing with a single observation.  </p><pre><code class="language-julia">x = [rand(Float32, 2) for i = 1:3]
julia&gt; m.(x)
3-element Array{Array{Float32,1},1}:
 [-0.17945863]
 [-0.20863166]
 [-0.20693761]</code></pre><p>If for some reason one wants to exclude the first step of the RNN chain for the computation of the loss, that can be handled with:</p><pre><code class="language-julia">function loss(x, y)
  sum((Flux.stack(m.(x)[2:end],1) .- y) .^ 2)
end

y = rand(Float32, 2)
julia&gt; loss(x, y)
1.7021208968648693</code></pre><p>In such model, only <code>y2</code> and <code>y3</code> are used to compute the loss, hence the target <code>y</code> being of length 2. This is a strategy that can be used to easily handle a <code>seq-to-one</code> kind of structure, compared to the <code>seq-to-seq</code> assumed so far.   </p><p>Alternatively, if one wants to perform some warmup of the sequence, it could be performed once, followed with a regular training where all the steps of the sequence would be considered for the gradient update:</p><pre><code class="language-julia">function loss(x, y)
  sum((Flux.stack(m.(x),1) .- y) .^ 2)
end

seq_init = [rand(Float32, 2) for i = 1:1]
seq_1 = [rand(Float32, 2) for i = 1:3]
seq_2 = [rand(Float32, 2) for i = 1:3]

y1 = rand(Float32, 3)
y2 = rand(Float32, 3)

X = [seq_1, seq_2]
Y = [y1, y2]
data = zip(X,Y)

Flux.reset!(m)
m.(seq_init)

ps = params(m)
opt= ADAM(1e-3)
Flux.train!(loss, ps, data, opt)</code></pre><p>In this previous example, model&#39;s state is first reset with <code>Flux.reset!</code>. Then, there&#39;s a warmup that is performed over a sequence of length 1 by feeding it with <code>seq_init</code>, resulting in a warmup state. The model can then be trained for 1 epoch, where 2 batches are provided (<code>seq_1</code> and <code>seq_2</code>) and all the timesteps outputs are considered for the loss (we no longer use a subset of <code>m.(x)</code> in the loss function).</p><p>In this scenario, it is important to note that a single continuous sequence is considered. Since the model state is not reset between the 2 batches, the state of the model flows through the batches, which only makes sense in the context where <code>seq_1</code> is the continuation of <code>seq_init</code> and so on.</p><p>Batch size would be 1 here as there&#39;s only a single sequence within each batch. If the model was to be trained on multiple independent sequences, then these sequences could be added to the input data as a second dimension. For example, in a language model, each batch would contain multiple independent sentences. In such scenario, if we set the batch size to 4, a single batch would be of the shape:</p><pre><code class="language-julia">batch = [rand(Float32, 2, 4) for i = 1:3]</code></pre><p>That would mean that we have 4 sentences (or samples), each with 2 features (let&#39;s say a very small embedding!) and each with a length of 3 (3 words per sentence). Computing <code>m(batch[1])</code>, would still represent <code>x1 -&gt; y1</code> in our diagram and returns the first word output, but now for each of the 4 independent sentences (second dimension of the input matrix).</p><p>In many situations, such as when dealing with a language model, each batch typically contains independent sentences, so we cannot handle the model as if each batch was the direct continuation of the previous one. To handle such situation, we need to reset the state of the model between each batch, which can be conveniently performed within the loss function:</p><pre><code class="language-julia">function loss(x, y)
  Flux.reset!(m)
  sum((Flux.stack(m.(x),1) .- y) .^ 2)
end</code></pre><p>A potential source of ambiguity of RNN in Flux can come from the different data layout compared to some common frameworks where data is typically a 3 dimensional array: <code>(features, seq length, samples)</code>. In Flux, those 3 dimensions are provided through a vector of seq length containing a matrix <code>(features, samples)</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basics/">« Basics</a><a class="docs-footer-nextpage" href="../layers/">Model Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 11 February 2021 08:39">Thursday 11 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
