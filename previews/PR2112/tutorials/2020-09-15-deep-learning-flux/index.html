<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Julia &amp; Flux: 60 Minute Blitz Â· Flux</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-36890222-9"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-36890222-9', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/flux.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="Flux logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="Flux logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../">Welcome</a></li><li><a class="tocitem" href="../../models/quickstart/">Quick Start</a></li><li><a class="tocitem" href="../../models/overview/">Fitting a Line</a></li><li><a class="tocitem" href="../../models/basics/">Gradients and Layers</a></li></ul></li><li><span class="tocitem">Building Models</span><ul><li><a class="tocitem" href="../../models/layers/">Built-in Layers ðŸ“š</a></li><li><a class="tocitem" href="../../models/recurrence/">Recurrence</a></li><li><a class="tocitem" href="../../models/activation/">Activation Functions ðŸ“š</a></li><li><a class="tocitem" href="../../models/nnlib/">NNlib.jl ðŸ“š (<code>softmax</code>, <code>conv</code>, ...)</a></li></ul></li><li><span class="tocitem">Handling Data</span><ul><li><a class="tocitem" href="../../data/mlutils/">MLUtils.jl ðŸ“š (<code>DataLoader</code>, ...)</a></li><li><a class="tocitem" href="../../data/onehot/">OneHotArrays.jl ðŸ“š (<code>onehot</code>, ...)</a></li></ul></li><li><span class="tocitem">Training Models</span><ul><li><a class="tocitem" href="../../training/training/">Training</a></li><li><a class="tocitem" href="../../models/regularisation/">Regularisation</a></li><li><a class="tocitem" href="../../models/losses/">Loss Functions ðŸ“š</a></li><li><a class="tocitem" href="../../training/optimisers/">Optimisation Rules ðŸ“š</a></li><li><a class="tocitem" href="../../training/callbacks/">Callback Helpers ðŸ“š</a></li><li><a class="tocitem" href="../../training/zygote/">Zygote.jl ðŸ“š (<code>gradient</code>, ...)</a></li></ul></li><li><span class="tocitem">Model Tools</span><ul><li><a class="tocitem" href="../../gpu/">GPU Support</a></li><li><a class="tocitem" href="../../saving/">Saving &amp; Loading</a></li><li><a class="tocitem" href="../../outputsize/">Shape Inference ðŸ“š</a></li><li><a class="tocitem" href="../../utilities/">Weight Initialisation ðŸ“š</a></li><li><a class="tocitem" href="../../destructure/">Flat vs. Nested ðŸ“š</a></li><li><a class="tocitem" href="../../models/functors/">Functors.jl ðŸ“š (<code>fmap</code>, ...)</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../linear_regression/">Linear Regression</a></li><li class="is-active"><a class="tocitem" href>Julia &amp; Flux: 60 Minute Blitz</a><ul class="internal"><li><a class="tocitem" href="#Arrays"><span>Arrays</span></a></li><li><a class="tocitem" href="#Automatic-Differentiation"><span>Automatic Differentiation</span></a></li><li><a class="tocitem" href="#Training-a-Classifier"><span>Training a Classifier</span></a></li></ul></li><li><a class="tocitem" href="../2021-01-26-mlp/">Multi-layer Perceptron</a></li><li><a class="tocitem" href="../2021-02-07-convnet/">Simple ConvNet</a></li><li><a class="tocitem" href="../2021-10-14-vanilla-gan/">Generative Adversarial Net</a></li><li><a class="tocitem" href="../2021-10-08-dcgan-mnist/">Deep Convolutional GAN</a></li><li><a class="tocitem" href="../../models/advanced/">Custom Layers</a></li></ul></li><li><a class="tocitem" href="../../performance/">Performance Tips</a></li><li><a class="tocitem" href="../../ecosystem/">Flux&#39;s Ecosystem</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Julia &amp; Flux: 60 Minute Blitz</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Julia &amp; Flux: 60 Minute Blitz</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FluxML/Flux.jl/blob/master/docs/src/tutorials/2020-09-15-deep-learning-flux.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="man-blitz"><a class="docs-heading-anchor" href="#man-blitz">Deep Learning with Julia &amp; Flux: A 60 Minute Blitz</a><a id="man-blitz-1"></a><a class="docs-heading-anchor-permalink" href="#man-blitz" title="Permalink"></a></h1><p>This is a quick intro to <a href="https://github.com/FluxML/Flux.jl">Flux</a> loosely based on <a href="https://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html">PyTorch&#39;s tutorial</a>. It introduces basic Julia programming, as well Zygote, a source-to-source automatic differentiation (AD) framework in Julia. We&#39;ll use these tools to build a very simple neural network.</p><h2 id="Arrays"><a class="docs-heading-anchor" href="#Arrays">Arrays</a><a id="Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Arrays" title="Permalink"></a></h2><p>The starting point for all of our models is the <code>Array</code> (sometimes referred to as a <code>Tensor</code> in other frameworks). This is really just a list of numbers, which might be arranged into a shape like a square. Let&#39;s write down an array with three elements.</p><pre><code class="language-julia hljs">x = [1, 2, 3]</code></pre><p>Here&#39;s a matrix â€“ a square array with four elements.</p><pre><code class="language-julia hljs">x = [1 2; 3 4]</code></pre><p>We often work with arrays of thousands of elements, and don&#39;t usually write them down by hand. Here&#39;s how we can create an array of 5Ã—3 = 15 elements, each a random number from zero to one.</p><pre><code class="language-julia hljs">x = rand(5, 3)</code></pre><p>There&#39;s a few functions like this; try replacing <code>rand</code> with <code>ones</code>, <code>zeros</code>, or <code>randn</code> to see what they do.</p><p>By default, Julia works stores numbers is a high-precision format called <code>Float64</code>. In ML we often don&#39;t need all those digits, and can ask Julia to work with <code>Float32</code> instead. We can even ask for more digits using <code>BigFloat</code>.</p><pre><code class="language-julia hljs">x = rand(BigFloat, 5, 3)

x = rand(Float32, 5, 3)</code></pre><p>We can ask the array how many elements it has.</p><pre><code class="language-julia hljs">length(x)</code></pre><p>Or, more specifically, what size it has.</p><pre><code class="language-julia hljs">size(x)</code></pre><p>We sometimes want to see some elements of the array on their own.</p><pre><code class="language-julia hljs">x

x[2, 3]</code></pre><p>This means get the second row and the third column. We can also get every row of the third column.</p><pre><code class="language-julia hljs">x[:, 3]</code></pre><p>We can add arrays, and subtract them, which adds or subtracts each element of the array.</p><pre><code class="language-julia hljs">x + x

x - x</code></pre><p>Julia supports a feature called <em>broadcasting</em>, using the <code>.</code> syntax. This tiles small arrays (or single numbers) to fill bigger ones.</p><pre><code class="language-julia hljs">x .+ 1</code></pre><p>We can see Julia tile the column vector <code>1:5</code> across all rows of the larger array.</p><pre><code class="language-julia hljs">zeros(5,5) .+ (1:5)</code></pre><p>The x&#39; syntax is used to transpose a column <code>1:5</code> into an equivalent row, and Julia will tile that across columns.</p><pre><code class="language-julia hljs">zeros(5,5) .+ (1:5)&#39;</code></pre><p>We can use this to make a times table.</p><pre><code class="language-julia hljs">(1:5) .* (1:5)&#39;</code></pre><p>Finally, and importantly for machine learning, we can conveniently do things like matrix multiply.</p><pre><code class="language-julia hljs">W = randn(5, 10)
x = rand(10)
W * x</code></pre><p>Julia&#39;s arrays are very powerful, and you can learn more about what they can do <a href="https://docs.julialang.org/en/v1/manual/arrays/">here</a>.</p><h3 id="CUDA-Arrays"><a class="docs-heading-anchor" href="#CUDA-Arrays">CUDA Arrays</a><a id="CUDA-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#CUDA-Arrays" title="Permalink"></a></h3><p>CUDA functionality is provided separately by the <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA package</a>. If you have a GPU and CUDA available, you can run <code>] add CUDA</code> in a REPL or IJulia to get it.</p><p>Once CUDA is loaded you can move any array to the GPU with the <code>cu</code> function, and it supports all of the above operations with the same syntax.</p><pre><code class="language-julia hljs">using CUDA
x = cu(rand(5, 3))</code></pre><h2 id="Automatic-Differentiation"><a class="docs-heading-anchor" href="#Automatic-Differentiation">Automatic Differentiation</a><a id="Automatic-Differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Differentiation" title="Permalink"></a></h2><p>You probably learned to take derivatives in school. We start with a simple mathematical function like</p><pre><code class="language-julia hljs">f(x) = 3x^2 + 2x + 1

f(5)</code></pre><p>In simple cases it&#39;s pretty easy to work out the gradient by hand â€“ here it&#39;s <code>6x+2</code>. But it&#39;s much easier to make Flux do the work for us!</p><pre><code class="language-julia hljs">using Flux: gradient

df(x) = gradient(f, x)[1]

df(5)</code></pre><p>You can try this with a few different inputs to make sure it&#39;s really the same as <code>6x+2</code>. We can even do this multiple times (but the second derivative is a fairly boring <code>6</code>).</p><pre><code class="language-julia hljs">ddf(x) = gradient(df, x)[1]

ddf(5)</code></pre><p>Flux&#39;s AD can handle any Julia code you throw at it, including loops, recursion and custom layers, so long as the mathematical functions you call are differentiable. For example, we can differentiate a Taylor approximation to the <code>sin</code> function.</p><pre><code class="language-julia hljs">mysin(x) = sum((-1)^k*x^(1+2k)/factorial(1+2k) for k in 0:5)

x = 0.5

mysin(x), gradient(mysin, x)

sin(x), cos(x)</code></pre><p>You can see that the derivative we calculated is very close to <code>cos(x)</code>, as we expect.</p><p>This gets more interesting when we consider functions that take <em>arrays</em> as inputs, rather than just a single number. For example, here&#39;s a function that takes a matrix and two vectors (the definition itself is arbitrary)</p><pre><code class="language-julia hljs">myloss(W, b, x) = sum(W * x .+ b)

W = randn(3, 5)
b = zeros(3)
x = rand(5)

gradient(myloss, W, b, x)</code></pre><p>Now we get gradients for each of the inputs <code>W</code>, <code>b</code> and <code>x</code>, which will come in handy when we want to train models.</p><p>Because ML models can contain hundreds of parameters, Flux provides a slightly different way of writing <code>gradient</code>. We instead mark arrays with <code>param</code> to indicate that we want their derivatives. <code>W</code> and <code>b</code> represent the weight and bias respectively.</p><pre><code class="language-julia hljs">using Flux: params

W = randn(3, 5)
b = zeros(3)
x = rand(5)

y(x) = sum(W * x .+ b)

grads = gradient(()-&gt;y(x), params([W, b]))

grads[W], grads[b]</code></pre><p>We can now grab the gradients of <code>W</code> and <code>b</code> directly from those parameters.</p><p>This comes in handy when working with <em>layers</em>. A layer is just a handy container for some parameters. For example, <code>Dense</code> does a linear transform for you.</p><pre><code class="language-julia hljs">using Flux

m = Dense(10, 5)

x = rand(Float32, 10)</code></pre><p>We can easily get the parameters of any layer or model with params with <code>params</code>.</p><pre><code class="language-julia hljs">params(m)</code></pre><p>This makes it very easy to calculate the gradient for all parameters in a network, even if it has many parameters.</p><pre><code class="language-julia hljs">x = rand(Float32, 10)
m = Chain(Dense(10, 5, relu), Dense(5, 2), softmax)
l(x) = sum(Flux.crossentropy(m(x), [0.5, 0.5]))
grads = gradient(params(m)) do
    l(x)
end
for p in params(m)
    println(grads[p])
end</code></pre><p>You don&#39;t have to use layers, but they can be convient for many simple kinds of models and fast iteration.</p><p>The next step is to update our weights and perform optimisation. As you might be familiar, <em>Gradient Descent</em> is a simple algorithm that takes the weights and steps using a learning rate and the gradients. <code>weights = weights - learning_rate * gradient</code>.</p><pre><code class="language-julia hljs">using Flux.Optimise: update!, Descent
Î· = 0.1
for p in params(m)
  update!(p, -Î· * grads[p])
end</code></pre><p>While this is a valid way of updating our weights, it can get more complicated as the algorithms we use get more involved.</p><p>Flux comes with a bunch of pre-defined optimisers and makes writing our own really simple. We just give it the learning rate Î·:</p><pre><code class="language-julia hljs">opt = Descent(0.01)</code></pre><p><code>Training</code> a network reduces down to iterating on a dataset mulitple times, performing these steps in order. Just for a quick implementation, letâ€™s train a network that learns to predict <code>0.5</code> for every input of 10 floats. <code>Flux</code> defines the <code>train!</code> function to do it for us.</p><pre><code class="language-julia hljs">data, labels = rand(10, 100), fill(0.5, 2, 100)
loss(x, y) = sum(Flux.crossentropy(m(x), y))
Flux.train!(loss, params(m), [(data,labels)], opt)</code></pre><p>You don&#39;t have to use <code>train!</code>. In cases where aribtrary logic might be better suited, you could open up this training loop like so:</p><pre><code class="language-julia hljs">  for d in training_set # assuming d looks like (data, labels)
    # our super logic
    gs = gradient(params(m)) do #m is our model
      l = loss(d...)
    end
    update!(opt, params(m), gs)
  end</code></pre><h2 id="Training-a-Classifier"><a class="docs-heading-anchor" href="#Training-a-Classifier">Training a Classifier</a><a id="Training-a-Classifier-1"></a><a class="docs-heading-anchor-permalink" href="#Training-a-Classifier" title="Permalink"></a></h2><p>Getting a real classifier to work might help cement the workflow a bit more. <a href="https://https://www.cs.toronto.edu/~kriz/cifar.html">CIFAR10</a> is a dataset of 50k tiny training images split into 10 classes.</p><p>We will do the following steps in order:</p><ul><li>Load CIFAR10 training and test datasets</li><li>Define a Convolution Neural Network</li><li>Define a loss function</li><li>Train the network on the training data</li><li>Test the network on the test data</li></ul><h3 id="Loading-the-Dataset"><a class="docs-heading-anchor" href="#Loading-the-Dataset">Loading the Dataset</a><a id="Loading-the-Dataset-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-the-Dataset" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Statistics
using Flux, Flux.Optimise
using MLDatasets: CIFAR10
using Images.ImageCore
using Flux: onehotbatch, onecold
using Base.Iterators: partition
using CUDA</code></pre><p>This image will give us an idea of what we are dealing with. </p><p><img src="https://pytorch.org/tutorials/_images/cifar10.png" alt="title"/></p><pre><code class="language-julia hljs">train_x, train_y = CIFAR10.traindata(Float32)
labels = onehotbatch(train_y, 0:9)</code></pre><p>The <code>train_x</code> contains 50000 images converted to 32 X 32 X 3 arrays with the third dimension being the 3 channels (R,G,B). Let&#39;s take a look at a random image from the train_x. For this, we need to permute the dimensions to 3 X 32 X 32 and use <code>colorview</code> to convert it back to an image. </p><pre><code class="language-julia hljs">using Plots
image(x) = colorview(RGB, permutedims(x, (3, 2, 1)))
plot(image(train_x[:,:,:,rand(1:end)]))</code></pre><p>We can now arrange the training data in batches of say, 1000 and keep a validation set to track our progress. This process is called minibatch learning, which is a popular method of training large neural networks. Rather that sending the entire dataset at once, we break it down into smaller chunks (called minibatches) that are typically chosen at random, and train only on them. It is shown to help with escaping <a href="https://en.wikipedia.org/wiki/Saddle_point">saddle points</a>.</p><p>The first 49k images (in batches of 1000) will be our training set, and the rest is for validation. <code>partition</code> handily breaks down the set we give it in consecutive parts (1000 in this case).</p><pre><code class="language-julia hljs">train = ([(train_x[:,:,:,i], labels[:,i]) for i in partition(1:49000, 1000)]) |&gt; gpu
valset = 49001:50000
valX = train_x[:,:,:,valset] |&gt; gpu
valY = labels[:, valset] |&gt; gpu</code></pre><h3 id="Defining-the-Classifier"><a class="docs-heading-anchor" href="#Defining-the-Classifier">Defining the Classifier</a><a id="Defining-the-Classifier-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Classifier" title="Permalink"></a></h3><p>Now we can define our Convolutional Neural Network (CNN).</p><p>A convolutional neural network is one which defines a kernel and slides it across a matrix to create an intermediate representation to extract features from. It creates higher order features as it goes into deeper layers, making it suitable for images, where the strucure of the subject is what will help us determine which class it belongs to.</p><pre><code class="language-julia hljs">m = Chain(
  Conv((5,5), 3=&gt;16, relu),
  MaxPool((2,2)),
  Conv((5,5), 16=&gt;8, relu),
  MaxPool((2,2)),
  x -&gt; reshape(x, :, size(x, 4)),
  Dense(200, 120),
  Dense(120, 84),
  Dense(84, 10),
  softmax) |&gt; gpu</code></pre><p>We will use a crossentropy loss and an Momentum optimiser here. Crossentropy will be a good option when it comes to working with mulitple independent classes. Momentum gradually lowers the learning rate as we proceed with the training. It helps maintain a bit of adaptivity in our optimisation, preventing us from over shooting from our desired destination.</p><pre><code class="language-julia hljs">using Flux: crossentropy, Momentum

loss(x, y) = sum(crossentropy(m(x), y))
opt = Momentum(0.01)</code></pre><p>We can start writing our train loop where we will keep track of some basic accuracy numbers about our model. We can define an <code>accuracy</code> function for it like so.</p><pre><code class="language-julia hljs">accuracy(x, y) = mean(onecold(m(x), 0:9) .== onecold(y, 0:9))</code></pre><h3 id="Training-the-Classifier"><a class="docs-heading-anchor" href="#Training-the-Classifier">Training the Classifier</a><a id="Training-the-Classifier-1"></a><a class="docs-heading-anchor-permalink" href="#Training-the-Classifier" title="Permalink"></a></h3><p>Training is where we do a bunch of the interesting operations we defined earlier, and see what our net is capable of. We will loop over the dataset 10 times and feed the inputs to the neural network and optimise.</p><pre><code class="language-julia hljs">epochs = 10

for epoch = 1:epochs
  for d in train
    gs = gradient(params(m)) do
      l = loss(d...)
    end
    update!(opt, params(m), gs)
  end
  @show accuracy(valX, valY)
end</code></pre><p>Seeing our training routine unfold gives us an idea of how the network learnt the function. This is not bad for a small hand-written network, trained for a limited time.</p><h3 id="Training-on-a-GPU"><a class="docs-heading-anchor" href="#Training-on-a-GPU">Training on a GPU</a><a id="Training-on-a-GPU-1"></a><a class="docs-heading-anchor-permalink" href="#Training-on-a-GPU" title="Permalink"></a></h3><p>The <code>gpu</code> functions you see sprinkled through this bit of the code tell Flux to move these entities to an available GPU, and subsequently train on it. No extra faffing about required! The same bit of code would work on any hardware with some small annotations like you saw here.</p><h3 id="Testing-the-Network"><a class="docs-heading-anchor" href="#Testing-the-Network">Testing the Network</a><a id="Testing-the-Network-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-the-Network" title="Permalink"></a></h3><p>We have trained the network for 100 passes over the training dataset. But we need to check if the network has learnt anything at all.</p><p>We will check this by predicting the class label that the neural network outputs, and checking it against the ground-truth. If the prediction is correct, we add the sample to the list of correct predictions. This will be done on a yet unseen section of data.</p><p>Okay, first step. Let us perform the exact same preprocessing on this set, as we did on our training set.</p><pre><code class="language-julia hljs">test_x, test_y = CIFAR10.testdata(Float32)
test_labels = onehotbatch(test_y, 0:9)

test = gpu.([(test_x[:,:,:,i], test_labels[:,i]) for i in partition(1:10000, 1000)])</code></pre><p>Next, display an image from the test set.</p><pre><code class="language-julia hljs">plot(image(test_x[:,:,:,rand(1:end)]))</code></pre><p>The outputs are energies for the 10 classes. Higher the energy for a class, the more the network thinks that the image is of the particular class. Every column corresponds to the output of one image, with the 10 floats in the column being the energies.</p><p>Let&#39;s see how the model fared.</p><pre><code class="language-julia hljs">ids = rand(1:10000, 5)
rand_test = test_x[:,:,:,ids] |&gt; gpu
rand_truth = test_y[ids]
m(rand_test)</code></pre><p>This looks similar to how we would expect the results to be. At this point, it&#39;s a good idea to see how our net actually performs on new data, that we have prepared.</p><pre><code class="language-julia hljs">accuracy(test[1]...)</code></pre><p>This is much better than random chance set at 10% (since we only have 10 classes), and not bad at all for a small hand written network like ours.</p><p>Let&#39;s take a look at how the net performed on all the classes performed individually.</p><pre><code class="language-julia hljs">class_correct = zeros(10)
class_total = zeros(10)
for i in 1:10
  preds = m(test[i][1])
  lab = test[i][2]
  for j = 1:1000
    pred_class = findmax(preds[:, j])[2]
    actual_class = findmax(lab[:, j])[2]
    if pred_class == actual_class
      class_correct[pred_class] += 1
    end
    class_total[actual_class] += 1
  end
end

class_correct ./ class_total</code></pre><p>The spread seems pretty good, with certain classes performing significantly better than the others. Why should that be?</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Originally published at <a href="https://fluxml.ai/tutorials/">fluxml.ai</a> on 15 November 2020. Written by Saswat Das, Mike Innes, Andrew Dinhobl, Ygor Canalli, Sudhanshu Agrawal, JoÃ£o Felipe Santos.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../linear_regression/">Â« Linear Regression</a><a class="docs-footer-nextpage" href="../2021-01-26-mlp/">Multi-layer Perceptron Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 30 November 2022 13:32">Wednesday 30 November 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
