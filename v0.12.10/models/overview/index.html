<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Overview · Flux</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-36890222-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script data-main="../../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../../assets/themeswap.js"></script><link href="../../assets/flux.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img alt="Flux logo" src="../../assets/logo.png"/></a><div class="docs-package-name"><span class="docs-autofit">Flux</span></div><form action="../../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Building Models</span><ul><li class="is-active"><a class="tocitem" href="">Overview</a><ul class="internal"><li><a class="tocitem" href="#Make-a-Trivial-Prediction"><span>Make a Trivial Prediction</span></a></li><li><a class="tocitem" href="#Provide-Training-and-Test-Data"><span>Provide Training and Test Data</span></a></li><li><a class="tocitem" href="#Build-a-Model-to-Make-Predictions"><span>Build a Model to Make Predictions</span></a></li><li><a class="tocitem" href="#Improve-the-Prediction"><span>Improve the Prediction</span></a></li><li><a class="tocitem" href="#Iteratively-Train-the-Model"><span>Iteratively Train the Model</span></a></li><li><a class="tocitem" href="#Verify-the-Results"><span>Verify the Results</span></a></li></ul></li><li><a class="tocitem" href="../basics/">Basics</a></li><li><a class="tocitem" href="../recurrence/">Recurrence</a></li><li><a class="tocitem" href="../layers/">Model Reference</a></li><li><a class="tocitem" href="../losses/">Loss Functions</a></li><li><a class="tocitem" href="../regularisation/">Regularisation</a></li><li><a class="tocitem" href="../advanced/">Advanced Model Building</a></li><li><a class="tocitem" href="../nnlib/">NNlib</a></li><li><a class="tocitem" href="../functors/">Functors</a></li></ul></li><li><span class="tocitem">Handling Data</span><ul><li><a class="tocitem" href="../../data/onehot/">One-Hot Encoding</a></li><li><a class="tocitem" href="../../data/dataloader/">DataLoader</a></li></ul></li><li><span class="tocitem">Training Models</span><ul><li><a class="tocitem" href="../../training/optimisers/">Optimisers</a></li><li><a class="tocitem" href="../../training/training/">Training</a></li></ul></li><li><a class="tocitem" href="../../gpu/">GPU Support</a></li><li><a class="tocitem" href="../../saving/">Saving &amp; Loading</a></li><li><a class="tocitem" href="../../ecosystem/">The Julia Ecosystem</a></li><li><a class="tocitem" href="../../utilities/">Utility Functions</a></li><li><a class="tocitem" href="../../performance/">Performance Tips</a></li><li><a class="tocitem" href="../../datasets/">Datasets</a></li><li><a class="tocitem" href="../../community/">Community</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Building Models</a></li><li class="is-active"><a href="">Overview</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Overview</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FluxML/Flux.jl/blob/master/docs/src/models/overview.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="Flux-Overview"><a class="docs-heading-anchor" href="#Flux-Overview">Flux Overview</a><a id="Flux-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Flux-Overview" title="Permalink"></a></h1><p>Flux is a pure Julia ML stack that allows you to build predictive models. Here are the steps for a typical Flux program:</p><ul><li>Provide training and test data</li><li>Build a model with configurable <em>parameters</em> to make predictions</li><li>Iteratively train the model by tweaking the parameters to improve predictions</li><li>Verify your model</li></ul><p>Under the hood, Flux uses a technique called automatic differentiation to take gradients that help improve predictions. Flux is also fully written in Julia so you can easily replace any layer of Flux with your own code to improve your understanding or satisfy special requirements.</p><p>Here's how you'd use Flux to build and train the most basic of models, step by step.</p><h2 id="Make-a-Trivial-Prediction"><a class="docs-heading-anchor" href="#Make-a-Trivial-Prediction">Make a Trivial Prediction</a><a id="Make-a-Trivial-Prediction-1"></a><a class="docs-heading-anchor-permalink" href="#Make-a-Trivial-Prediction" title="Permalink"></a></h2><p>This example will predict the output of the function <code>4x + 2</code>. First, import <code>Flux</code> and define the function we want to simulate:</p><pre><code class="language-julia">julia&gt; using Flux

julia&gt; actual(x) = 4x + 2
actual (generic function with 1 method)</code></pre><p>This example will build a model to approximate the <code>actual</code> function.</p><h2 id="Provide-Training-and-Test-Data"><a class="docs-heading-anchor" href="#Provide-Training-and-Test-Data">Provide Training and Test Data</a><a id="Provide-Training-and-Test-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Provide-Training-and-Test-Data" title="Permalink"></a></h2><p>Use the <code>actual</code> function to build sets of data for training and verification:</p><pre><code class="language-julia">julia&gt; x_train, x_test = hcat(0:5...), hcat(6:10...)
([0 1 … 4 5], [6 7 … 9 10])

julia&gt; y_train, y_test = actual.(x_train), actual.(x_test)
([2 6 … 18 22], [26 30 … 38 42])</code></pre><p>Normally, your training and test data come from real world observations, but this function will simulate real-world observations.</p><h2 id="Build-a-Model-to-Make-Predictions"><a class="docs-heading-anchor" href="#Build-a-Model-to-Make-Predictions">Build a Model to Make Predictions</a><a id="Build-a-Model-to-Make-Predictions-1"></a><a class="docs-heading-anchor-permalink" href="#Build-a-Model-to-Make-Predictions" title="Permalink"></a></h2><p>Now, build a model to make predictions with <code>1</code> input and <code>1</code> output:</p><pre><code class="language-julia">julia&gt; model = Dense(1, 1)
Dense(1, 1)

julia&gt; model.weight
1×1 Matrix{Float32}:
 -1.4925033

julia&gt; model.bias
1-element Vector{Float32}:
 0.0</code></pre><p>Under the hood, a dense layer is a struct with fields <code>weight</code> and <code>bias</code>. <code>weight</code> represents a weights' matrix and <code>bias</code> represents a bias vector. There's another way to think about a model. In Flux, <em>models are conceptually predictive functions</em>: </p><pre><code class="language-julia">julia&gt; predict = Dense(1, 1)</code></pre><p><code>Dense(1, 1)</code> also implements the function <code>σ(Wx+b)</code> where <code>W</code> and <code>b</code> are the weights and biases. <code>σ</code> is an activation function (more on activations later). Our model has one weight and one bias, but typical models will have many more. Think of weights and biases as knobs and levers Flux can use to tune predictions. Activation functions are transformations that tailor models to your needs. </p><p>This model will already make predictions, though not accurate ones yet:</p><pre><code class="language-julia">julia&gt; predict(x_train)
1×6 Matrix{Float32}:
 0.0  -1.4925  -2.98501  -4.47751  -5.97001  -7.46252</code></pre><p>In order to make better predictions, you'll need to provide a <em>loss function</em> to tell Flux how to objectively <em>evaluate</em> the quality of a prediction. Loss functions compute the cumulative distance between actual values and predictions. </p><pre><code class="language-julia">julia&gt; loss(x, y) = Flux.Losses.mse(predict(x), y)
loss (generic function with 1 method)

julia&gt; loss(x_train, y_train)
282.16010605766024</code></pre><p>More accurate predictions will yield a lower loss. You can write your own loss functions or rely on those already provided by Flux. This loss function is called <a href="https://www.statisticshowto.com/probability-and-statistics/statistics-definitions/mean-squared-error/">mean squared error</a>. Flux works by iteratively reducing the loss through <em>training</em>.</p><h2 id="Improve-the-Prediction"><a class="docs-heading-anchor" href="#Improve-the-Prediction">Improve the Prediction</a><a id="Improve-the-Prediction-1"></a><a class="docs-heading-anchor-permalink" href="#Improve-the-Prediction" title="Permalink"></a></h2><p>Under the hood, the Flux <a href="../../training/training/#Flux.Optimise.train!"><code>Flux.train!</code></a> function uses <em>a loss function</em> and <em>training data</em> to improve the <em>parameters</em> of your model based on a pluggable <a href="../../training/optimisers/"><code>optimiser</code></a>:</p><pre><code class="language-julia">julia&gt; using Flux: train!

julia&gt; opt = Descent()
Descent(0.1)

julia&gt; data = [(x_train, y_train)]
1-element Array{Tuple{Array{Int64,2},Array{Int64,2}},1}:
 ([0 1 … 4 5], [2 6 … 18 22])</code></pre><p>Now, we have the optimiser and data we'll pass to <code>train!</code>. All that remains are the parameters of the model. Remember, each model is a Julia struct with a function and configurable parameters. Remember, the dense layer has weights and biases that depend on the dimensions of the inputs and outputs: </p><pre><code class="language-julia">julia&gt; predict.weight
1-element Array{Float64,1}:
 -0.99009055

julia&gt; predict.bias
1-element Array{Float64,1}:
 0.0</code></pre><p>The dimensions of these model parameters depend on the number of inputs and outputs. Since models can have hundreds of inputs and several layers, it helps to have a function to collect the parameters into the data structure Flux expects:</p><pre><code class="language-none">julia&gt; parameters = Flux.params(predict)
Params([[-0.99009055], [0.0]])</code></pre><p>These are the parameters Flux will change, one step at a time, to improve predictions. At each step, the contents of this <code>Params</code> object changes too, since it is just a collection of references to the mutable arrays inside the model: </p><pre><code class="language-none">julia&gt; predict.weight in parameters, predict.bias in parameters
(true, true)
</code></pre><p>The first parameter is the weight and the second is the bias. Flux will adjust predictions by iteratively changing these parameters according to the optimizer.</p><p>This optimiser implements the classic gradient descent strategy. Now improve the parameters of the model with a call to <a href="../../training/training/#Flux.Optimise.train!"><code>Flux.train!</code></a> like this:</p><pre><code class="language-none">julia&gt; train!(loss, parameters, data, opt)</code></pre><p>And check the loss:</p><pre><code class="language-none">julia&gt; loss(x_train, y_train)
267.8037f0</code></pre><p>It went down. Why? </p><pre><code class="language-none">julia&gt; parameters
Params([[9.158408791666668], [2.895045275]])</code></pre><p>The parameters have changed. This single step is the essence of machine learning.</p><h2 id="Iteratively-Train-the-Model"><a class="docs-heading-anchor" href="#Iteratively-Train-the-Model">Iteratively Train the Model</a><a id="Iteratively-Train-the-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Iteratively-Train-the-Model" title="Permalink"></a></h2><p>In the previous section, we made a single call to <code>train!</code> which iterates over the data we passed in just once. An <em>epoch</em> refers to one pass over the dataset. Typically, we will run the training for multiple epochs to drive the loss down even further. Let's run it a few more times:</p><pre><code class="language-none">julia&gt; for epoch in 1:200
         train!(loss, parameters, data, opt)
       end

julia&gt; loss(x_train, y_train)
0.007433314787010791

julia&gt; parameters
Params([[3.9735880692372345], [1.9925541368157165]])</code></pre><p>After 200 training steps, the loss went down, and the parameters are getting close to those in the function the model is built to predict.</p><h2 id="Verify-the-Results"><a class="docs-heading-anchor" href="#Verify-the-Results">Verify the Results</a><a id="Verify-the-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Verify-the-Results" title="Permalink"></a></h2><p>Now, let's verify the predictions:</p><pre><code class="language-none">julia&gt; predict(x_test)
1×5 Array{Float64,2}:
 25.8442  29.8194  33.7946  37.7698  41.745

julia&gt; y_test
1×5 Array{Int64,2}:
 26  30  34  38  42</code></pre><p>The predictions are good. Here's how we got there. </p><p>First, we gathered real-world data into the variables <code>x_train</code>, <code>y_train</code>, <code>x_test</code>, and <code>y_test</code>. The <code>x_*</code> data defines inputs, and the <code>y_*</code> data defines outputs. The <code>*_train</code> data is for training the model, and the <code>*_test</code> data is for verifying the model. Our data was based on the function <code>4x + 2</code>.</p><p>Then, we built a single input, single output predictive model, <code>predict = Dense(1, 1)</code>. The initial predictions weren't accurate, because we had not trained the model yet.</p><p>After building the model, we trained it with <code>train!(loss, parameters, data, opt)</code>. The loss function is first, followed by the <code>parameters</code> holding the weights and biases of the model, the training data, and the <code>Descent</code> optimizer provided by Flux. We ran the training step once, and observed that the parameters changed and the loss went down. Then, we ran the <code>train!</code> many times to finish the training process.</p><p>After we trained the model, we verified it with the test data to verify the results. </p><p>This overall flow represents how Flux works. Let's drill down a bit to understand what's going on inside the individual layers of Flux.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../basics/">Basics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 7 April 2022 07:21">Thursday 7 April 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>