<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Model Reference · Flux</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-36890222-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script data-main="../../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../../assets/themeswap.js"></script><link href="../../assets/flux.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img alt="Flux logo" src="../../assets/logo.png"/></a><div class="docs-package-name"><span class="docs-autofit">Flux</span></div><form action="../../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Building Models</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../basics/">Basics</a></li><li><a class="tocitem" href="../recurrence/">Recurrence</a></li><li class="is-active"><a class="tocitem" href="">Model Reference</a><ul class="internal"><li><a class="tocitem" href="#Convolution-and-Pooling-Layers"><span>Convolution and Pooling Layers</span></a></li><li><a class="tocitem" href="#Upsampling-Layers"><span>Upsampling Layers</span></a></li><li><a class="tocitem" href="#Recurrent-Layers"><span>Recurrent Layers</span></a></li><li><a class="tocitem" href="#Other-General-Purpose-Layers"><span>Other General Purpose Layers</span></a></li><li><a class="tocitem" href="#Normalisation-and-Regularisation"><span>Normalisation &amp; Regularisation</span></a></li></ul></li><li><a class="tocitem" href="../losses/">Loss Functions</a></li><li><a class="tocitem" href="../regularisation/">Regularisation</a></li><li><a class="tocitem" href="../advanced/">Advanced Model Building</a></li><li><a class="tocitem" href="../nnlib/">NNlib</a></li><li><a class="tocitem" href="../functors/">Functors</a></li></ul></li><li><span class="tocitem">Handling Data</span><ul><li><a class="tocitem" href="../../data/onehot/">One-Hot Encoding</a></li><li><a class="tocitem" href="../../data/mlutils/">MLUtils</a></li></ul></li><li><span class="tocitem">Training Models</span><ul><li><a class="tocitem" href="../../training/optimisers/">Optimisers</a></li><li><a class="tocitem" href="../../training/training/">Training</a></li></ul></li><li><a class="tocitem" href="../../gpu/">GPU Support</a></li><li><a class="tocitem" href="../../saving/">Saving &amp; Loading</a></li><li><a class="tocitem" href="../../ecosystem/">The Julia Ecosystem</a></li><li><a class="tocitem" href="../../utilities/">Utility Functions</a></li><li><a class="tocitem" href="../../performance/">Performance Tips</a></li><li><a class="tocitem" href="../../datasets/">Datasets</a></li><li><a class="tocitem" href="../../community/">Community</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Building Models</a></li><li class="is-active"><a href="">Model Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Model Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FluxML/Flux.jl/blob/master/docs/src/models/layers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="Basic-Layers"><a class="docs-heading-anchor" href="#Basic-Layers">Basic Layers</a><a id="Basic-Layers-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Layers" title="Permalink"></a></h1><p>These core layers form the foundation of almost all neural networks.</p><article class="docstring"><header><a class="docstring-binding" href="#Flux.Chain" id="Flux.Chain"><code>Flux.Chain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Chain(layers...)
Chain(name = layer, ...)</code></pre><p>Collects multiple layers / functions to be called in sequence on a given input. Supports indexing and slicing, <code>m[2]</code> or <code>m[1:end-1]</code>, and if names are given, <code>m[:name] == m[1]</code> etc.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; m = Chain(x -&gt; x^2, x -&gt; x+1);

julia&gt; m(5) == 26
true

julia&gt; m = Chain(Dense(10 =&gt; 5, tanh), Dense(5 =&gt; 2));

julia&gt; x = rand(10, 32);

julia&gt; m(x) == m[2](m[1](x))
true

julia&gt; m2 = Chain(enc = Chain(Flux.flatten, Dense(10 =&gt; 5, tanh)), 
                  dec = Dense(5 =&gt; 2));

julia&gt; m2(x) == (m2[:dec] ∘ m2[:enc])(x)
true</code></pre><p>For large models, there is a special type-unstable path which can reduce compilation times. This can be used by supplying a vector of layers <code>Chain([layer1, layer2, ...])</code>. This feature is somewhat experimental, beware!</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/basic.jl#L1-L34" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.Dense" id="Flux.Dense"><code>Flux.Dense</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Dense(in =&gt; out, σ=identity; bias=true, init=glorot_uniform)
Dense(W::AbstractMatrix, [bias, σ])</code></pre><p>Create a traditional fully connected layer, whose forward pass is given by:</p><pre><code class="language-none">y = σ.(W * x .+ bias)</code></pre><p>The input <code>x</code> should be a vector of length <code>in</code>, or batch of vectors represented as an <code>in × N</code> matrix, or any array with <code>size(x,1) == in</code>. The out <code>y</code> will be a vector  of length <code>out</code>, or a batch with <code>size(y) == (out, size(x)[2:end]...)</code></p><p>Keyword <code>bias=false</code> will switch off trainable bias for the layer. The initialisation of the weight matrix is <code>W = init(out, in)</code>, calling the function given to keyword <code>init</code>, with default <a href="models/@doc Flux.glorot_uniform"><code>glorot_uniform</code></a>. The weight matrix and/or the bias vector (of length <code>out</code>) may also be provided explicitly.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dense(5 =&gt; 2)
Dense(5 =&gt; 2)       # 12 parameters

julia&gt; d(rand(Float32, 5, 64)) |&gt; size
(2, 64)

julia&gt; d(rand(Float32, 5, 1, 1, 64)) |&gt; size  # treated as three batch dimensions
(2, 1, 1, 64)

julia&gt; d1 = Dense(ones(2, 5), false, tanh)  # using provided weight matrix
Dense(5 =&gt; 2, tanh; bias=false)  # 10 parameters

julia&gt; d1(ones(5))
2-element Vector{Float64}:
 0.9999092042625951
 0.9999092042625951

julia&gt; Flux.params(d1)  # no trainable bias
Params([[1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]])</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/basic.jl#L99-L139" target="_blank">source</a></section></article><h2 id="Convolution-and-Pooling-Layers"><a class="docs-heading-anchor" href="#Convolution-and-Pooling-Layers">Convolution and Pooling Layers</a><a id="Convolution-and-Pooling-Layers-1"></a><a class="docs-heading-anchor-permalink" href="#Convolution-and-Pooling-Layers" title="Permalink"></a></h2><p>These layers are used to build convolutional neural networks (CNNs).</p><article class="docstring"><header><a class="docstring-binding" href="#Flux.Conv" id="Flux.Conv"><code>Flux.Conv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Conv(filter, in =&gt; out, σ = identity;
     stride = 1, pad = 0, dilation = 1, groups = 1, [bias, init])</code></pre><p>Standard convolutional layer. <code>filter</code> is a tuple of integers specifying the size of the convolutional kernel; <code>in</code> and <code>out</code> specify the number of input and output channels.</p><p>Image data should be stored in WHCN order (width, height, channels, batch). In other words, a 100×100 RGB image would be a <code>100×100×3×1</code> array, and a batch of 50 would be a <code>100×100×3×50</code> array. This has <code>N = 2</code> spatial dimensions, and needs a kernel size like <code>(5,5)</code>, a 2-tuple of integers.</p><p>To take convolutions along <code>N</code> feature dimensions, this layer expects as input an array with <code>ndims(x) == N+2</code>, where <code>size(x, N+1) == in</code> is the number of input channels, and <code>size(x, ndims(x))</code> is (as always) the number of observations in a batch. Then:</p><ul><li><code>filter</code> should be a tuple of <code>N</code> integers.</li><li>Keywords <code>stride</code> and <code>dilation</code> should each be either single integer, or a tuple with <code>N</code> integers.</li><li>Keyword <code>pad</code> specifies the number of elements added to the borders of the data array. It can be<ul><li>a single integer for equal padding all around,</li><li>a tuple of <code>N</code> integers, to apply the same padding at begin/end of each spatial dimension,</li><li>a tuple of <code>2*N</code> integers, for asymmetric padding, or</li><li>the singleton <code>SamePad()</code>, to calculate padding such that <code>size(output,d) == size(x,d) / stride</code> (possibly rounded) for each spatial dimension.</li></ul></li><li>Keyword <code>groups</code> is expected to be an <code>Int</code>. It specifies the number of groups to divide a convolution into.</li></ul><p>Keywords to control initialization of the layer:</p><ul><li><code>init</code> - Function used to generate initial weights. Defaults to <code>glorot_uniform</code>.</li><li><code>bias</code> - The initial bias vector is all zero by default. Trainable bias can be disabled entirely by setting this to <code>false</code>, or another vector can be provided such as <code>bias = randn(Float32, out)</code>.</li></ul><p>See also <a href="#Flux.ConvTranspose"><code>ConvTranspose</code></a>, <a href="#Flux.DepthwiseConv"><code>DepthwiseConv</code></a>, <a href="#Flux.CrossCor"><code>CrossCor</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50); # a batch of images

julia&gt; layer = Conv((5,5), 3 =&gt; 7, relu; bias = false)
Conv((5, 5), 3 =&gt; 7, relu, bias=false)  # 525 parameters

julia&gt; layer(xs) |&gt; size
(96, 96, 7, 50)

julia&gt; Conv((5,5), 3 =&gt; 7; stride = 2)(xs) |&gt; size
(48, 48, 7, 50)

julia&gt; Conv((5,5), 3 =&gt; 7; stride = 2, pad = SamePad())(xs) |&gt; size
(50, 50, 7, 50)

julia&gt; Conv((1,1), 3 =&gt; 7; pad = (20,10,0,0))(xs) |&gt; size
(130, 100, 7, 50)

julia&gt; Conv((5,5), 3 =&gt; 7; stride = 2, dilation = 4)(xs) |&gt; size
(42, 42, 7, 50)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/conv.jl#L37-L96" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.AdaptiveMaxPool" id="Flux.AdaptiveMaxPool"><code>Flux.AdaptiveMaxPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AdaptiveMaxPool(out::NTuple)</code></pre><p>Adaptive max pooling layer. Calculates the necessary window size such that its output has <code>size(y)[1:N] == out</code>.</p><p>Expects as input an array with <code>ndims(x) == N+2</code>, i.e. channel and batch dimensions, after the <code>N</code> feature dimensions, where <code>N = length(out)</code>.</p><p>See also <a href="#Flux.MaxPool"><code>MaxPool</code></a>, <a href="#Flux.AdaptiveMeanPool"><code>AdaptiveMeanPool</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50);  # batch of 50 RGB images

julia&gt; AdaptiveMaxPool((25, 25))(xs) |&gt; size
(25, 25, 3, 50)

julia&gt; MaxPool((4,4))(xs) ≈ AdaptiveMaxPool((25, 25))(xs)
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/conv.jl#L427-L448" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.MaxPool" id="Flux.MaxPool"><code>Flux.MaxPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MaxPool(window::NTuple; pad=0, stride=window)</code></pre><p>Max pooling layer, which replaces all pixels in a block of size <code>window</code> with one.</p><p>Expects as input an array with <code>ndims(x) == N+2</code>, i.e. channel and batch dimensions, after the <code>N</code> feature dimensions, where <code>N = length(window)</code>.</p><p>By default the window size is also the stride in each dimension. The keyword <code>pad</code> accepts the same options as for the <code>Conv</code> layer, including <code>SamePad()</code>.</p><p>See also <a href="#Flux.Conv"><code>Conv</code></a>, <a href="#Flux.MeanPool"><code>MeanPool</code></a>, <a href="#Flux.AdaptiveMaxPool"><code>AdaptiveMaxPool</code></a>, <a href="#Flux.GlobalMaxPool"><code>GlobalMaxPool</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50);  # batch of 50 RGB images

julia&gt; m = Chain(Conv((5, 5), 3 =&gt; 7, pad=SamePad()), MaxPool((5, 5), pad=SamePad()))
Chain(
  Conv((5, 5), 3 =&gt; 7, pad=2),          # 532 parameters
  MaxPool((5, 5), pad=2),
)

julia&gt; m[1](xs) |&gt; size
(100, 100, 7, 50)

julia&gt; m(xs) |&gt; size
(20, 20, 7, 50)

julia&gt; lay = MaxPool((5,), pad=2, stride=(3,))  # one-dimensional window
MaxPool((5,), pad=2, stride=3)

julia&gt; lay(rand(Float32, 100, 7, 50)) |&gt; size
(34, 7, 50)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/conv.jl#L582-L620" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.GlobalMaxPool" id="Flux.GlobalMaxPool"><code>Flux.GlobalMaxPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GlobalMaxPool()</code></pre><p>Global max pooling layer.</p><p>Transforms (w,h,c,b)-shaped input into (1,1,c,b)-shaped output, by performing max pooling on the complete (w,h)-shaped feature maps.</p><p>See also <a href="#Flux.MaxPool"><code>MaxPool</code></a>, <a href="#Flux.GlobalMeanPool"><code>GlobalMeanPool</code></a>.</p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50);

julia&gt; m = Chain(Conv((3,3), 3 =&gt; 7), GlobalMaxPool());

julia&gt; m(xs) |&gt; size
(1, 1, 7, 50)

julia&gt; GlobalMaxPool()(rand(3,5,7)) |&gt; size  # preserves 2 dimensions
(1, 5, 7)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/conv.jl#L509-L530" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.AdaptiveMeanPool" id="Flux.AdaptiveMeanPool"><code>Flux.AdaptiveMeanPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AdaptiveMeanPool(out::NTuple)</code></pre><p>Adaptive mean pooling layer. Calculates the necessary window size such that its output has <code>size(y)[1:N] == out</code>.</p><p>Expects as input an array with <code>ndims(x) == N+2</code>, i.e. channel and batch dimensions, after the <code>N</code> feature dimensions, where <code>N = length(out)</code>.</p><p>See also <a href="#Flux.MaxPool"><code>MaxPool</code></a>, <a href="#Flux.AdaptiveMaxPool"><code>AdaptiveMaxPool</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50);  # batch of 50 RGB images

julia&gt; AdaptiveMeanPool((25, 25))(xs) |&gt; size
(25, 25, 3, 50)

julia&gt; MeanPool((4,4))(xs) ≈ AdaptiveMeanPool((25, 25))(xs)
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/conv.jl#L468-L489" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.MeanPool" id="Flux.MeanPool"><code>Flux.MeanPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MeanPool(window::NTuple; pad=0, stride=window)</code></pre><p>Mean pooling layer, averaging all pixels in a block of size <code>window</code>.</p><p>Expects as input an array with <code>ndims(x) == N+2</code>, i.e. channel and batch dimensions, after the <code>N</code> feature dimensions, where <code>N = length(window)</code>.</p><p>By default the window size is also the stride in each dimension. The keyword <code>pad</code> accepts the same options as for the <code>Conv</code> layer, including <code>SamePad()</code>.</p><p>See also <a href="#Flux.Conv"><code>Conv</code></a>, <a href="#Flux.MaxPool"><code>MaxPool</code></a>, <a href="#Flux.AdaptiveMeanPool"><code>AdaptiveMeanPool</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50);

julia&gt; m = Chain(Conv((5,5), 3 =&gt; 7), MeanPool((5,5), pad=SamePad()))
Chain(
  Conv((5, 5), 3 =&gt; 7),                 # 532 parameters
  MeanPool((5, 5), pad=2),
)

julia&gt; m[1](xs) |&gt; size
(96, 96, 7, 50)

julia&gt; m(xs) |&gt; size
(20, 20, 7, 50)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/conv.jl#L648-L679" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.GlobalMeanPool" id="Flux.GlobalMeanPool"><code>Flux.GlobalMeanPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GlobalMeanPool()</code></pre><p>Global mean pooling layer.</p><p>Transforms (w,h,c,b)-shaped input into (1,1,c,b)-shaped output, by performing mean pooling on the complete (w,h)-shaped feature maps.</p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50);

julia&gt; m = Chain(Conv((3,3), 3 =&gt; 7), GlobalMeanPool());

julia&gt; m(xs) |&gt; size
(1, 1, 7, 50)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/conv.jl#L548-L564" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.DepthwiseConv" id="Flux.DepthwiseConv"><code>Flux.DepthwiseConv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DepthwiseConv(filter, in =&gt; out, σ=identity; stride=1, pad=0, dilation=1, [bias, init])
DepthwiseConv(weight::AbstractArray, [bias, activation; stride, pad, dilation])</code></pre><p>Return a depthwise convolutional layer, that is a <a href="#Flux.Conv"><code>Conv</code></a> layer with number of groups equal to the number of input channels.</p><p>See <a href="#Flux.Conv"><code>Conv</code></a> for a description of the arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50);  # a batch of 50 RGB images

julia&gt; lay = DepthwiseConv((5,5), 3 =&gt; 6, relu; bias=false)
Conv((5, 5), 3 =&gt; 6, relu, groups=3, bias=false)  # 150 parameters 

julia&gt; lay(xs) |&gt; size
(96, 96, 6, 50)

julia&gt; DepthwiseConv((5, 5), 3 =&gt; 9, stride=2, pad=2)(xs) |&gt; size
(50, 50, 9, 50)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/conv.jl#L307-L330" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.ConvTranspose" id="Flux.ConvTranspose"><code>Flux.ConvTranspose</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConvTranspose(filter, in =&gt; out, σ=identity; stride=1, pad=0, dilation=1, [bias, init])</code></pre><p>Standard convolutional transpose layer. <code>filter</code> is a tuple of integers specifying the size of the convolutional kernel, while <code>in</code> and <code>out</code> specify the number of input and output channels.</p><p>Note that <code>pad=SamePad()</code> here tries to ensure <code>size(output,d) == size(x,d) * stride</code>.</p><p>Parameters are controlled by additional keywords, with defaults <code>init=glorot_uniform</code> and <code>bias=true</code>.</p><p>See also <a href="#Flux.Conv"><code>Conv</code></a> for more detailed description of keywords.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50);  # a batch of 50 RGB images

julia&gt; lay = ConvTranspose((5,5), 3 =&gt; 7, relu)
ConvTranspose((5, 5), 3 =&gt; 7, relu)  # 532 parameters

julia&gt; lay(xs) |&gt; size
(104, 104, 7, 50)

julia&gt; ConvTranspose((5,5), 3 =&gt; 7, stride=2)(xs) |&gt; size
(203, 203, 7, 50)

julia&gt; ConvTranspose((5,5), 3 =&gt; 7, stride=3, pad=SamePad())(xs) |&gt; size
(300, 300, 7, 50)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/conv.jl#L200-L230" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.CrossCor" id="Flux.CrossCor"><code>Flux.CrossCor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CrossCor(filter, in =&gt; out, σ=identity; stride=1, pad=0, dilation=1, [bias, init])</code></pre><p>Standard cross convolutional layer. <code>filter</code> is a tuple of integers specifying the size of the convolutional kernel; <code>in</code> and <code>out</code> specify the number of input and output channels.</p><p>Parameters are controlled by additional keywords, with defaults <code>init=glorot_uniform</code> and <code>bias=true</code>.</p><p>See also <a href="#Flux.Conv"><code>Conv</code></a> for more detailed description of keywords.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; xs = rand(Float32, 100, 100, 3, 50);  # a batch of 50 RGB images

julia&gt; lay = CrossCor((5,5), 3 =&gt; 6, relu; bias=false)
CrossCor((5, 5), 3 =&gt; 6, relu, bias=false)  # 450 parameters

julia&gt; lay(xs) |&gt; size
(96, 96, 6, 50)

julia&gt; CrossCor((5,5), 3 =&gt; 7, stride=3, pad=(2,0))(xs) |&gt; size
(34, 32, 7, 50)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/conv.jl#L343-L369" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.SamePad" id="Flux.SamePad"><code>Flux.SamePad</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SamePad()</code></pre><p>Passed as an option to convolutional layers (and friends), this causes the padding to be chosen such that the input and output sizes agree (on the first <code>N</code> dimensions, the kernel or window) when <code>stride==1</code>. When <code>stride≠1</code>, the output size equals <code>ceil(input_size/stride)</code>.</p><p>See also <a href="#Flux.Conv"><code>Conv</code></a>, <a href="#Flux.MaxPool"><code>MaxPool</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/conv.jl#L13-L22" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.flatten" id="Flux.flatten"><code>Flux.flatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">flatten(x::AbstractArray)</code></pre><p>Reshape arbitrarly-shaped input into a matrix-shaped output, preserving the size of the last dimension.</p><p>See also <a href="../../data/mlutils/#MLUtils.unsqueeze"><code>unsqueeze</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rand(3,4,5) |&gt; Flux.flatten |&gt; size
(12, 5)

julia&gt; xs = rand(Float32, 10,10,3,7);

julia&gt; m = Chain(Conv((3,3), 3 =&gt; 4, pad=1), Flux.flatten, Dense(400 =&gt; 33));

julia&gt; xs |&gt; m[1] |&gt; size
(10, 10, 4, 7)

julia&gt; xs |&gt; m |&gt; size
(33, 7)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/stateless.jl#L1-L24" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.convfilter" id="Flux.convfilter"><code>Flux.convfilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">convfilter(filter::Tuple, in =&gt; out[; init = glorot_uniform])</code></pre><p>Constructs a standard convolutional weight matrix with given <code>filter</code> and channels from <code>in</code> to <code>out</code>.</p><p>Accepts the keyword <code>init</code> (default: <code>glorot_uniform</code>) to control the sampling distribution.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/conv.jl#L149-L157" target="_blank">source</a></section></article><h2 id="Upsampling-Layers"><a class="docs-heading-anchor" href="#Upsampling-Layers">Upsampling Layers</a><a id="Upsampling-Layers-1"></a><a class="docs-heading-anchor-permalink" href="#Upsampling-Layers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#Flux.Upsample" id="Flux.Upsample"><code>Flux.Upsample</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Upsample(mode = :nearest; [scale, size]) 
Upsample(scale, mode = :nearest)</code></pre><p>An upsampling layer. One of two keywords must be given:</p><p>If <code>scale</code> is a number, this applies to all but the last two dimensions (channel and batch) of the input.  It may also be a tuple, to control dimensions individually. Alternatively, keyword  <code>size</code> accepts a tuple, to directly specify the leading dimensions of the output.</p><p>Currently supported upsampling <code>mode</code>s  and corresponding NNlib's methods are:</p><ul><li><code>:nearest</code> -&gt; <a href="../nnlib/#NNlib.upsample_nearest"><code>NNlib.upsample_nearest</code></a></li><li><code>:bilinear</code> -&gt; <a href="../nnlib/#NNlib.upsample_bilinear"><code>NNlib.upsample_bilinear</code></a></li><li><code>:trilinear</code> -&gt; <a href="../nnlib/#NNlib.upsample_trilinear"><code>NNlib.upsample_trilinear</code></a></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; m = Upsample(scale = (2, 3))
Upsample(:nearest, scale = (2, 3))

julia&gt; m(ones(2, 2, 1, 1)) |&gt; size
(4, 6, 1, 1)

julia&gt; m = Upsample(:bilinear, size = (4, 5))
Upsample(:bilinear, size = (4, 5))

julia&gt; m(ones(2, 2, 1, 1)) |&gt; size
(4, 5, 1, 1)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/upsample.jl#L1-L32" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.PixelShuffle" id="Flux.PixelShuffle"><code>Flux.PixelShuffle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PixelShuffle(r::Int)</code></pre><p>Pixel shuffling layer with upscale factor <code>r</code>.</p><p>See <a href="../nnlib/#NNlib.pixel_shuffle"><code>NNlib.pixel_shuffle</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/upsample.jl#L75-L81" target="_blank">source</a></section></article><h2 id="Recurrent-Layers"><a class="docs-heading-anchor" href="#Recurrent-Layers">Recurrent Layers</a><a id="Recurrent-Layers-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrent-Layers" title="Permalink"></a></h2><p>Much like the core layers above, but can be used to process sequence data (as well as other kinds of structured data).</p><article class="docstring"><header><a class="docstring-binding" href="#Flux.RNN" id="Flux.RNN"><code>Flux.RNN</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RNN(in =&gt; out, σ = tanh)</code></pre><p>The most basic recurrent layer; essentially acts as a <code>Dense</code> layer, but with the output fed back into the input each time step.</p><p>The arguments <code>in</code> and <code>out</code> describe the size of the feature vectors passed as input and as output. That is, it accepts a vector of length <code>in</code> or a batch of vectors represented as a <code>in x B</code> matrix and outputs a vector of length <code>out</code> or a batch of vectors of size <code>out x B</code>.</p><p>This constructor is syntactic sugar for <code>Recur(RNNCell(a...))</code>, and so RNNs are stateful. Note that the state shape can change depending on the inputs, and so it is good to <code>reset!</code> the model between inference calls if the batch size changes. See the examples below.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; r = RNN(3 =&gt; 5)
Recur(
  RNNCell(3 =&gt; 5, tanh),                # 50 parameters
)         # Total: 4 trainable arrays, 50 parameters,
          # plus 1 non-trainable, 5 parameters, summarysize 432 bytes.

julia&gt; r(rand(Float32, 3)) |&gt; size
(5,)

julia&gt; Flux.reset!(r);

julia&gt; r(rand(Float32, 3, 10)) |&gt; size # batch size of 10
(5, 10)</code></pre><div class="admonition is-warning"><header class="admonition-header">Batch size changes</header><div class="admonition-body"><p>Failing to call <code>reset!</code> when the input batch size changes can lead to unexpected behavior. See the following example:</p><pre><code class="language-julia">julia&gt; r = RNN(3 =&gt; 5)
Recur(
  RNNCell(3 =&gt; 5, tanh),                # 50 parameters
)         # Total: 4 trainable arrays, 50 parameters,
          # plus 1 non-trainable, 5 parameters, summarysize 432 bytes.

julia&gt; r.state |&gt; size
(5, 1)

julia&gt; r(rand(Float32, 3)) |&gt; size
(5,)

julia&gt; r.state |&gt; size
(5, 1)

julia&gt; r(rand(Float32, 3, 10)) |&gt; size # batch size of 10
(5, 10)

julia&gt; r.state |&gt; size # state shape has changed
(5, 10)

julia&gt; r(rand(Float32, 3)) |&gt; size # erroneously outputs a length 5*10 = 50 vector.
(50,)</code></pre></div></div></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/recurrent.jl#L153-L209" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.LSTM" id="Flux.LSTM"><code>Flux.LSTM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">LSTM(in =&gt; out)</code></pre><p><a href="https://www.researchgate.net/publication/13853244_Long_Short-term_Memory">Long Short Term Memory</a> recurrent layer. Behaves like an RNN but generally exhibits a longer memory span over sequences.</p><p>The arguments <code>in</code> and <code>out</code> describe the size of the feature vectors passed as input and as output. That is, it accepts a vector of length <code>in</code> or a batch of vectors represented as a <code>in x B</code> matrix and outputs a vector of length <code>out</code> or a batch of vectors of size <code>out x B</code>.</p><p>This constructor is syntactic sugar for <code>Recur(LSTMCell(a...))</code>, and so LSTMs are stateful. Note that the state shape can change depending on the inputs, and so it is good to <code>reset!</code> the model between inference calls if the batch size changes. See the examples below.</p><p>See <a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">this article</a> for a good overview of the internals.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; l = LSTM(3 =&gt; 5)
Recur(
  LSTMCell(3 =&gt; 5),                     # 190 parameters
)         # Total: 5 trainable arrays, 190 parameters,
          # plus 2 non-trainable, 10 parameters, summarysize 1.062 KiB.

julia&gt; l(rand(Float32, 3)) |&gt; size
(5,)

julia&gt; Flux.reset!(l);

julia&gt; l(rand(Float32, 3, 10)) |&gt; size # batch size of 10
(5, 10)</code></pre><div class="admonition is-warning"><header class="admonition-header">Batch size changes</header><div class="admonition-body"><p>Failing to call <code>reset!</code> when the input batch size changes can lead to unexpected behavior. See the example in <a href="#Flux.RNN"><code>RNN</code></a>.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/recurrent.jl#L245-L277" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.GRU" id="Flux.GRU"><code>Flux.GRU</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">GRU(in =&gt; out)</code></pre><p><a href="https://arxiv.org/abs/1406.1078v1">Gated Recurrent Unit</a> layer. Behaves like an RNN but generally exhibits a longer memory span over sequences. This implements the variant proposed in v1 of the referenced paper.</p><p>The integer arguments <code>in</code> and <code>out</code> describe the size of the feature vectors passed as input and as output. That is, it accepts a vector of length <code>in</code> or a batch of vectors represented as a <code>in x B</code> matrix and outputs a vector of length <code>out</code> or a batch of vectors of size <code>out x B</code>.</p><p>This constructor is syntactic sugar for <code>Recur(GRUCell(a...))</code>, and so GRUs are stateful. Note that the state shape can change depending on the inputs, and so it is good to <code>reset!</code> the model between inference calls if the batch size changes. See the examples below.</p><p>See <a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">this article</a> for a good overview of the internals.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = GRU(3 =&gt; 5)
Recur(
  GRUCell(3 =&gt; 5),                      # 140 parameters
)         # Total: 4 trainable arrays, 140 parameters,
          # plus 1 non-trainable, 5 parameters, summarysize 792 bytes.

julia&gt; g(rand(Float32, 3)) |&gt; size
(5,)

julia&gt; Flux.reset!(g);

julia&gt; g(rand(Float32, 3, 10)) |&gt; size # batch size of 10
(5, 10)</code></pre><div class="admonition is-warning"><header class="admonition-header">Batch size changes</header><div class="admonition-body"><p>Failing to call <code>reset!</code> when the input batch size changes can lead to unexpected behavior. See the example in <a href="#Flux.RNN"><code>RNN</code></a>.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/recurrent.jl#L313-L346" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.Recur" id="Flux.Recur"><code>Flux.Recur</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Recur(cell)</code></pre><p><code>Recur</code> takes a recurrent cell and makes it stateful, managing the hidden state in the background. <code>cell</code> should be a model of the form:</p><pre><code class="language-none">h, y = cell(h, x...)</code></pre><p>For example, here's a recurrent network that keeps a running total of its inputs:</p><pre><code class="language-julia">accum(h, x) = (h + x, x)
rnn = Flux.Recur(accum, 0)
rnn(2)      # 2
rnn(3)      # 3
rnn.state   # 5
rnn.(1:10)  # apply to a sequence
rnn.state   # 60</code></pre><p>Folding over a 3d Array of dimensions <code>(features, batch, time)</code> is also supported:</p><pre><code class="language-julia">accum(h, x) = (h .+ x, x)
rnn = Flux.Recur(accum, zeros(Int, 1, 1))
rnn([2])                    # 2
rnn([3])                    # 3
rnn.state                   # 5
rnn(reshape(1:10, 1, 1, :)) # apply to a sequence of (features, batch, time)
rnn.state                   # 60</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/recurrent.jl#L56-L88" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.reset!" id="Flux.reset!"><code>Flux.reset!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reset!(rnn)</code></pre><p>Reset the hidden state of a recurrent layer back to its original value.</p><p>Assuming you have a <code>Recur</code> layer <code>rnn</code>, this is roughly equivalent to:</p><pre><code class="language-julia">rnn.state = hidden(rnn.cell)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/recurrent.jl#L104-L113" target="_blank">source</a></section></article><h2 id="Other-General-Purpose-Layers"><a class="docs-heading-anchor" href="#Other-General-Purpose-Layers">Other General Purpose Layers</a><a id="Other-General-Purpose-Layers-1"></a><a class="docs-heading-anchor-permalink" href="#Other-General-Purpose-Layers" title="Permalink"></a></h2><p>These are marginally more obscure than the Basic Layers. But in contrast to the layers described in the other sections are not readily grouped around a particular purpose (e.g. CNNs or RNNs).</p><article class="docstring"><header><a class="docstring-binding" href="#Flux.Maxout" id="Flux.Maxout"><code>Flux.Maxout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Maxout(layers...)
Maxout(f, n_alts)</code></pre><p>This contains a number of internal layers, each of which receives the same input. Its output is the elementwise maximum of the the internal layers' outputs.</p><p>Instead of defining layers individually, you can provide a zero-argument function which constructs them, and the number to construct.</p><p>Maxout over linear dense layers satisfies the univeral approximation theorem. See Goodfellow, Warde-Farley, Mirza, Courville &amp; Bengio "Maxout Networks"  <a href="models/1302.4389">https://arxiv.org/abs/1302.4389</a>.</p><p>See also <a href="#Flux.Parallel"><code>Parallel</code></a> to reduce with other operators.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; m = Maxout(x -&gt; abs2.(x), x -&gt; x .* 3);

julia&gt; m([-2 -1 0 1 2])
1×5 Matrix{Int64}:
 4  1  0  3  6

julia&gt; m3 = Maxout(() -&gt; Dense(5 =&gt; 7, tanh), 3)
Maxout(
  Dense(5 =&gt; 7, tanh),                  # 42 parameters
  Dense(5 =&gt; 7, tanh),                  # 42 parameters
  Dense(5 =&gt; 7, tanh),                  # 42 parameters
)                   # Total: 6 arrays, 126 parameters, 888 bytes.

julia&gt; Flux.outputsize(m3, (5, 11))
(7, 11)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/basic.jl#L240-L274" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.SkipConnection" id="Flux.SkipConnection"><code>Flux.SkipConnection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SkipConnection(layer, connection)</code></pre><p>Create a skip connection which consists of a layer or <code>Chain</code> of consecutive layers and a shortcut connection linking the block's input to the output through a user-supplied 2-argument callable. The first argument to the callable will be propagated through the given <code>layer</code> while the second is the unchanged, "skipped" input.</p><p>The simplest "ResNet"-type connection is just <code>SkipConnection(layer, +)</code>. Here is a more complicated example:</p><pre><code class="language-julia-repl">julia&gt; m = Conv((3,3), 4 =&gt; 7, pad=(1,1));

julia&gt; x = ones(Float32, 5, 5, 4, 10);

julia&gt; size(m(x)) == (5, 5, 7, 10)
true

julia&gt; sm = SkipConnection(m, (mx, x) -&gt; cat(mx, x, dims=3));

julia&gt; size(sm(x)) == (5, 5, 11, 10)
true</code></pre><p>See also <a href="#Flux.Parallel"><code>Parallel</code></a>, <a href="#Flux.Maxout"><code>Maxout</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/basic.jl#L296-L322" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.Parallel" id="Flux.Parallel"><code>Flux.Parallel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Parallel(connection, layers...)
Parallel(connection; name = layer, ...)</code></pre><p>Create a layer which passes an input array to each path in <code>layers</code>, before reducing the output with <code>connection</code>.</p><p>Called with one input <code>x</code>, this is equivalent to <code>connection([l(x) for l in layers]...)</code>. If called with multiple inputs, one is passed to each layer, thus <code>Parallel(+, f, g)(x, y) = f(x) + g(y)</code>.</p><p>Like <a href="#Flux.Chain"><code>Chain</code></a>, its sub-layers may be given names using the keyword constructor. These can be accessed by indexing: <code>m[1] == m[:name]</code> is the first layer.</p><p>See also <a href="#Flux.SkipConnection"><code>SkipConnection</code></a> which is <code>Parallel</code> with one <code>identity</code>, and <a href="#Flux.Maxout"><code>Maxout</code></a> which reduces by broadcasting <code>max</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; model = Chain(Dense(3 =&gt; 5),
                     Parallel(vcat, Dense(5 =&gt; 4), Chain(Dense(5 =&gt; 7), Dense(7 =&gt; 4))),
                     Dense(8 =&gt; 17));

julia&gt; model(rand(3)) |&gt; size
(17,)

julia&gt; model2 = Parallel(+; α = Dense(10, 2, tanh), β = Dense(5, 2))
Parallel(
  +,
  α = Dense(10 =&gt; 2, tanh),             # 22 parameters
  β = Dense(5 =&gt; 2),                    # 12 parameters
)                   # Total: 4 arrays, 34 parameters, 392 bytes.

julia&gt; model2(rand(10), rand(5)) |&gt; size
(2,)

julia&gt; model2[:α](rand(10)) |&gt; size
(2,)

julia&gt; model2[:β] == model2[2]
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/basic.jl#L439-L481" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.Bilinear" id="Flux.Bilinear"><code>Flux.Bilinear</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Bilinear((in1, in2) =&gt; out, σ=identity; bias=true, init=glorot_uniform)
Bilinear(W::AbstractArray, [bias, σ])</code></pre><p>Creates a layer which is fully connected between two inputs and the output, and otherwise similar to <a href="#Flux.Dense"><code>Dense</code></a>. Its output, given vectors <code>x</code> &amp; <code>y</code>, is another vector <code>z</code> with, for all <code>i ∈ 1:out</code>:</p><pre><code class="language-none">z[i] = σ(x' * W[i,:,:] * y + bias[i])</code></pre><p>If <code>x</code> and <code>y</code> are matrices, then each column of the output <code>z = B(x, y)</code> is of this form, with <code>B</code> the Bilinear layer.</p><p>If the second input <code>y</code> is not given, it is taken to be equal to <code>x</code>, i.e. <code>B(x) == B(x, x)</code></p><p>The two inputs may also be provided as a tuple, <code>B((x, y)) == B(x, y)</code>, which is accepted as the input to a <code>Chain</code>.</p><p>If the two input sizes are the same, <code>in1 == in2</code>, then you may write <code>Bilinear(in =&gt; out, σ)</code>.</p><p>The initialisation works as for <a href="#Flux.Dense"><code>Dense</code></a> layer, with <code>W = init(out, in1, in2)</code>. By default the bias vector is <code>zeros(Float32, out)</code>, option <code>bias=false</code> will switch off trainable bias. Either of these may be provided explicitly.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x, y = randn(Float32, 5, 32), randn(Float32, 5, 32);

julia&gt; B = Flux.Bilinear((5, 5) =&gt; 7)
Bilinear(5 =&gt; 7)    # 182 parameters

julia&gt; B(x) |&gt; size  # interactions based on one input
(7, 32)

julia&gt; B(x,y) == B((x,y))  # two inputs, may be given as a tuple
true

julia&gt; sc = SkipConnection(
                Chain(Dense(5 =&gt; 20, tanh), Dense(20 =&gt; 9, tanh)),
                Flux.Bilinear((9, 5) =&gt; 3, bias=false),
            );  # used as the recombinator, with skip as the second input

julia&gt; sc(x) |&gt; size
(3, 32)

julia&gt; Flux.Bilinear(rand(4,8,16), false, tanh)  # first dim of weight is the output
Bilinear((8, 16) =&gt; 4, tanh; bias=false)  # 512 parameters</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/basic.jl#L338-L386" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.Scale" id="Flux.Scale"><code>Flux.Scale</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Scale(size::Integer..., σ=identity; bias=true, init=ones32)
Scale(scale::AbstractArray, [bias, σ])</code></pre><p>Create an element-wise layer, whose forward pass is given by:</p><pre><code class="language-none">y = σ.(scale .* x .+ bias)</code></pre><p>This uses <code>.*</code> instead of matrix multiplication <code>*</code> of <a href="#Flux.Dense"><code>Dense</code></a>.</p><p>The learnable scale &amp; bias are initialised <code>init(size...)</code> and <code>zeros32(size...)</code>, with <code>init=ones32</code> by default. You may specify the function <code>init</code>,  turn off trainable bias with <code>bias=false</code>, or provide the array(s) explicitly.</p><p>Used by <a href="#Flux.LayerNorm"><code>LayerNorm</code></a> with <code>affine=true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = Flux.Scale(2)
Scale(2)            # 4 parameters

julia&gt; Flux.params(a)
Params([Float32[1.0, 1.0], Float32[0.0, 0.0]])

julia&gt; a([1 2 3])
2×3 Matrix{Float32}:
 1.0  2.0  3.0
 1.0  2.0  3.0

julia&gt; b = Flux.Scale([1 2 3 4], false, abs2)
Scale(1, 4, abs2; bias=false)  # 4 parameters

julia&gt; b([1, 10])
2×4 Matrix{Int64}:
   1    4    9    16
 100  400  900  1600

julia&gt; Flux.params(b)
Params([[1 2 3 4]])</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/basic.jl#L172-L212" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.Embedding" id="Flux.Embedding"><code>Flux.Embedding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Embedding(in =&gt; out; init=randn)</code></pre><p>A lookup table that stores embeddings of dimension <code>out</code>  for a vocabulary of size <code>in</code>.</p><p>This layer is often used to store word embeddings and retrieve them using indices.  The input to the layer can be either a vector of indexes or the corresponding <a href="models/@ref Flux.OneHotArray">onehot encoding</a>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; vocab_size, embed_size = 1000, 4;

julia&gt; model = Flux.Embedding(vocab_size =&gt; embed_size)
Embedding(1000 =&gt; 4)  # 4_000 parameters

julia&gt; vocab_idxs = [1, 722, 53, 220, 3];

julia&gt; x = Flux.OneHotMatrix(vocab_idxs, vocab_size); summary(x)
"1000×5 OneHotMatrix(::Vector{Int64}) with eltype Bool"

julia&gt; model(x) |&gt; summary
"4×5 Matrix{Float32}"

julia&gt; model(vocab_idxs) == model(x)
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/basic.jl#L523-L551" target="_blank">source</a></section></article><h2 id="Normalisation-and-Regularisation"><a class="docs-heading-anchor" href="#Normalisation-and-Regularisation">Normalisation &amp; Regularisation</a><a id="Normalisation-and-Regularisation-1"></a><a class="docs-heading-anchor-permalink" href="#Normalisation-and-Regularisation" title="Permalink"></a></h2><p>These layers don't affect the structure of the network but may improve training times or reduce overfitting.</p><article class="docstring"><header><a class="docstring-binding" href="#Flux.normalise" id="Flux.normalise"><code>Flux.normalise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalise(x; dims=ndims(x), ϵ=1e-5)</code></pre><p>Normalise <code>x</code> to mean 0 and standard deviation 1 across the dimension(s) given by <code>dims</code>. Per default, <code>dims</code> is the last dimension.  <code>ϵ</code> is a small additive factor added to the denominator for numerical stability.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/stateless.jl#L29-L35" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.BatchNorm" id="Flux.BatchNorm"><code>Flux.BatchNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BatchNorm(channels::Integer, λ=identity;
          initβ=zeros32, initγ=ones32,
          affine = true, track_stats = true,
          ϵ=1f-5, momentum= 0.1f0)</code></pre><p><a href="https://arxiv.org/abs/1502.03167">Batch Normalization</a> layer. <code>channels</code> should be the size of the channel dimension in your data (see below).</p><p>Given an array with <code>N</code> dimensions, call the <code>N-1</code>th the channel dimension. For a batch of feature vectors this is just the data dimension, for <code>WHCN</code> images it's the usual channel dimension.</p><p><code>BatchNorm</code> computes the mean and variance for each <code>D_1×...×D_{N-2}×1×D_N</code> input slice and normalises the input accordingly.</p><p>If <code>affine=true</code>, it also applies  a shift and a rescale to the input through to learnable per-channel bias β and scale γ parameters.</p><p>After normalisation, elementwise activation <code>λ</code> is applied.</p><p>If <code>track_stats=true</code>, accumulates mean and var statistics in training phase that will be used to renormalize the input in test phase.</p><p>Use <a href="#Flux.testmode!"><code>testmode!</code></a> during inference.</p><p><strong>Examples</strong></p><pre><code class="language-julia">m = Chain(
  Dense(28^2 =&gt; 64),
  BatchNorm(64, relu),
  Dense(64 =&gt; 10),
  BatchNorm(10),
  softmax)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/normalise.jl#L232-L267" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.dropout" id="Flux.dropout"><code>Flux.dropout</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dropout([rng = rng_from_array(x)], x, p; dims=:, active=true)</code></pre><p>The dropout function. If <code>active</code> is <code>true</code>, for each input, either sets that input to <code>0</code> (with probability <code>p</code>) or scales it by <code>1 / (1 - p)</code>. <code>dims</code> specifies the unbroadcasted dimensions, e.g. <code>dims=1</code> applies dropout along columns and <code>dims=2</code> along rows. This is used as a regularisation, i.e. it reduces overfitting during training.</p><p>If <code>active</code> is <code>false</code>, it just returns the input <code>x</code>.</p><p>Specify <code>rng</code> for custom RNGs instead of the default RNG. Note that custom RNGs are only supported on the CPU.</p><p>Warning: when using this function, you have to manually manage the activation state. Usually in fact, dropout is used while training but is deactivated in the inference phase. This can be automatically managed using the <a href="#Flux.Dropout"><code>Dropout</code></a> layer instead of the <code>dropout</code> function.</p><p>The <a href="#Flux.Dropout"><code>Dropout</code></a> layer is what you should use in most scenarios.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/normalise.jl#L12-L33" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.Dropout" id="Flux.Dropout"><code>Flux.Dropout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Dropout(p; dims=:, rng = rng_from_array())</code></pre><p>Dropout layer. In the forward pass, apply the <a href="#Flux.dropout"><code>Flux.dropout</code></a> function on the input.</p><p>To apply dropout along certain dimension(s), specify the <code>dims</code> keyword. e.g. <code>Dropout(p; dims = 3)</code> will randomly zero out entire channels on WHCN input (also called 2D dropout).</p><p>Specify <code>rng</code> to use a custom RNG instead of the default. Custom RNGs are only supported on the CPU.</p><p>Does nothing to the input once <a href="#Flux.testmode!"><code>Flux.testmode!</code></a> is <code>true</code>.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/normalise.jl#L55-L68" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.AlphaDropout" id="Flux.AlphaDropout"><code>Flux.AlphaDropout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AlphaDropout(p; rng = rng_from_array())</code></pre><p>A dropout layer. Used in <a href="https://arxiv.org/abs/1706.02515">Self-Normalizing Neural Networks</a>. The AlphaDropout layer ensures that mean and variance of activations remain the same as before.</p><p>Does nothing to the input once <a href="#Flux.testmode!"><code>testmode!</code></a> is true.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/normalise.jl#L99-L108" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.LayerNorm" id="Flux.LayerNorm"><code>Flux.LayerNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LayerNorm(size..., λ=identity; affine=true, ϵ=1fe-5)</code></pre><p>A <a href="https://arxiv.org/abs/1607.06450">normalisation layer</a> designed to be used with recurrent hidden states. The argument <code>sz</code> should be an integer or a tuple of integers. In the forward pass, the layer normalises the mean and standard deviation of the input, the applied the elementwise activation <code>λ</code>. The input is normalised along the first <code>length(sz)</code> dimensions for tuple <code>sz</code>, along the first dimension for integer <code>sz</code>. The input  is expected to have first dimensions' size equal to <code>sz</code>.</p><p>If <code>affine=true</code> also applies a learnable shift and rescaling using the <a href="#Flux.Scale"><code>Scale</code></a> layer.</p><p>See also <a href="#Flux.BatchNorm"><code>BatchNorm</code></a>, <a href="#Flux.InstanceNorm"><code>InstanceNorm</code></a>, <a href="#Flux.GroupNorm"><code>GroupNorm</code></a>, and <a href="#Flux.normalise"><code>normalise</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/normalise.jl#L141-L158" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.InstanceNorm" id="Flux.InstanceNorm"><code>Flux.InstanceNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InstanceNorm(channels::Integer, λ=identity;
             initβ=zeros32, initγ=ones32,
             affine=false, track_stats=false,
             ϵ=1f-5, momentum=0.1f0)</code></pre><p><a href="https://arxiv.org/abs/1607.08022">Instance Normalization</a> layer. <code>channels</code> should be the size of the channel dimension in your data (see below).</p><p>Given an array with <code>N &gt; 2</code> dimensions, call the <code>N-1</code>th the channel dimension. For <code>WHCN</code> images it's the usual channel dimension.</p><p><code>InstanceNorm</code> computes the mean and variance for each <code>D_1×...×D_{N-2}×1×1</code> input slice and normalises the input accordingly.</p><p>If <code>affine=true</code>, it also applies  a shift and a rescale to the input through to learnable per-channel bias <code>β</code> and scale <code>γ</code> parameters.</p><p>If <code>track_stats=true</code>, accumulates mean and var statistics in training phase that will be used to renormalize the input in test phase.</p><p><strong>Warning</strong>: the defaults for <code>affine</code> and <code>track_stats</code> used to be <code>true</code> in previous Flux versions (&lt; v0.12).</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/normalise.jl#L320-L343" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.GroupNorm" id="Flux.GroupNorm"><code>Flux.GroupNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GroupNorm(channels::Integer, G::Integer, λ=identity;
          initβ=zeros32, initγ=ones32,
          affine=true, track_stats=false,
          ϵ=1f-5, momentum=0.1f0)</code></pre><p><a href="https://arxiv.org/abs/1803.08494">Group Normalization</a> layer.</p><p><code>chs</code> is the number of channels, the channel dimension of your input. For an array of N dimensions, the <code>N-1</code>th index is the channel dimension.</p><p><code>G</code> is the number of groups along which the statistics are computed. The number of channels must be an integer multiple of the number of groups.</p><p><code>channels</code> should be the size of the channel dimension in your data (see below).</p><p>Given an array with <code>N &gt; 2</code> dimensions, call the <code>N-1</code>th the channel dimension. For <code>WHCN</code> images it's the usual channel dimension.</p><p>If <code>affine=true</code>, it also applies  a shift and a rescale to the input through to learnable per-channel bias <code>β</code> and scale <code>γ</code> parameters.</p><p>If <code>track_stats=true</code>, accumulates mean and var statistics in training phase that will be used to renormalize the input in test phase.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/layers/normalise.jl#L396-L420" target="_blank">source</a></section></article><h3 id="Testmode"><a class="docs-heading-anchor" href="#Testmode">Testmode</a><a id="Testmode-1"></a><a class="docs-heading-anchor-permalink" href="#Testmode" title="Permalink"></a></h3><p>Many normalisation layers behave differently under training and inference (testing). By default, Flux will automatically determine when a layer evaluation is part of training or inference. Still, depending on your use case, it may be helpful to manually specify when these layers should be treated as being trained or not. For this, Flux provides <code>Flux.testmode!</code>. When called on a model (e.g. a layer or chain of layers), this function will place the model into the mode specified.</p><article class="docstring"><header><a class="docstring-binding" href="#Flux.testmode!" id="Flux.testmode!"><code>Flux.testmode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">testmode!(m, mode = true)</code></pre><p>Set a layer or model's test mode (see below). Using <code>:auto</code> mode will treat any gradient computation as training.</p><p><em>Note</em>: if you manually set a model into test mode, you need to manually place it back into train mode during training phase.</p><p>Possible values include:</p><ul><li><code>false</code> for training</li><li><code>true</code> for testing</li><li><code>:auto</code> or <code>nothing</code> for Flux to detect the mode automatically</li></ul></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/functor.jl#L7-L20" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.trainmode!" id="Flux.trainmode!"><code>Flux.trainmode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trainmode!(m, mode = true)</code></pre><p>Set a layer of model's train mode (see below). Symmetric to <a href="#Flux.testmode!"><code>testmode!</code></a> (i.e. <code>trainmode!(m, mode) == testmode!(m, !mode)</code>).</p><p><em>Note</em>: if you manually set a model into train mode, you need to manually place it into test mode during testing phase.</p><p>Possible values include:</p><ul><li><code>true</code> for training</li><li><code>false</code> for testing</li><li><code>:auto</code> or <code>nothing</code> for Flux to detect the mode automatically</li></ul></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/28ee7b408ed820e44c2a2b64d65d26f34d5c85e6/src/functor.jl#L23-L36" target="_blank">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../recurrence/">« Recurrence</a><a class="docs-footer-nextpage" href="../losses/">Loss Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 26 May 2022 17:12">Thursday 26 May 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>