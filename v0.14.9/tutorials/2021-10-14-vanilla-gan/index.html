<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial: Generative Adversarial Networks · Flux</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-36890222-9"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-36890222-9', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/flux.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="Flux logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="Flux logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../../models/quickstart/">Quick Start</a></li><li><a class="tocitem" href="../../models/overview/">Fitting a Line</a></li><li><a class="tocitem" href="../../models/basics/">Gradients and Layers</a></li><li><a class="tocitem" href="../../training/training/">Training</a></li><li><a class="tocitem" href="../../models/recurrence/">Recurrence</a></li><li><a class="tocitem" href="../../gpu/">GPU Support</a></li><li><a class="tocitem" href="../../saving/">Saving &amp; Loading</a></li><li><a class="tocitem" href="../../performance/">Performance Tips</a></li></ul></li><li><a class="tocitem" href="../../ecosystem/">Ecosystem</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../models/layers/">Built-in Layers</a></li><li><a class="tocitem" href="../../models/activation/">Activation Functions</a></li><li><a class="tocitem" href="../../utilities/">Weight Initialisation</a></li><li><a class="tocitem" href="../../models/losses/">Loss Functions</a></li><li><a class="tocitem" href="../../training/reference/">Training API</a></li><li><a class="tocitem" href="../../training/optimisers/">Optimisation Rules</a></li><li><a class="tocitem" href="../../outputsize/">Shape Inference</a></li><li><a class="tocitem" href="../../destructure/">Flat vs. Nested</a></li><li><a class="tocitem" href="../../training/callbacks/">Callback Helpers</a></li><li><a class="tocitem" href="../../training/zygote/">Gradients – Zygote.jl</a></li><li><a class="tocitem" href="../../data/mlutils/">Batching Data – MLUtils.jl</a></li><li><a class="tocitem" href="../../data/onehot/">OneHotArrays.jl</a></li><li><a class="tocitem" href="../../models/nnlib/">Low-level Operations – NNlib.jl</a></li><li><a class="tocitem" href="../../models/functors/">Nested Structures – Functors.jl</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../linear_regression/">Linear Regression</a></li><li><a class="tocitem" href="../logistic_regression/">Logistic Regression</a></li><li><a class="tocitem" href="../../models/advanced/">Custom Layers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial: Generative Adversarial Networks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial: Generative Adversarial Networks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FluxML/Flux.jl/blob/master/docs/src/tutorials/2021-10-14-vanilla-gan.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="[Tutorial:-Generative-Adversarial-Networks](](@id-man-gan-tutorial))"><a class="docs-heading-anchor" href="#[Tutorial:-Generative-Adversarial-Networks](](@id-man-gan-tutorial))"><a href="tutorials/](@id man-gan-tutorial)">Tutorial: Generative Adversarial Networks</a></a><a id="[Tutorial:-Generative-Adversarial-Networks](](@id-man-gan-tutorial))-1"></a><a class="docs-heading-anchor-permalink" href="#[Tutorial:-Generative-Adversarial-Networks](](@id-man-gan-tutorial))" title="Permalink"></a></h1><p>This tutorial describes how to implement a vanilla Generative Adversarial Network using Flux and how train it on the MNIST dataset. It is based on this <a href="https://medium.com/ai-society/gans-from-scratch-1-a-deep-introduction-with-code-in-pytorch-and-tensorflow-cb03cdcdba0f">Pytorch tutorial</a>. The original GAN <a href="https://arxiv.org/abs/1406.2661">paper</a> by Goodfellow et al. is a great resource that describes the motivation and theory behind GANs:</p><blockquote><p>In the proposed adversarial nets framework, the generative model is pitted against an adversary: a discriminative model that learns to determine whether a sample is from the model distribution or the data distribution. The generative model can be thought of as analogous to a team of counterfeiters, trying to produce fake currency and use it without detection, while the discriminative model is analogous to the police, trying to detect the counterfeit currency. Competition in this game drives both teams to improve their methods until the counterfeits are indistinguishable from the genuine articles.</p></blockquote><p>Let&#39;s implement a GAN in Flux. To get started we first import a few useful packages:</p><pre><code class="language-julia hljs">using MLDatasets: MNIST
using Flux.Data: DataLoader
using Flux
using CUDA
using Zygote
using UnicodePlots</code></pre><p>To download a package in the Julia REPL, type <code>]</code> to enter package mode and then type <code>add MLDatasets</code> or perform this operation with the Pkg module like this</p><pre><code class="language-julia hljs">&gt; import Pkg
&gt; Pkg.add(&quot;MLDatasets&quot;)</code></pre><p>While <a href="https://github.com/JuliaPlots/UnicodePlots.jl">UnicodePlots</a> is not necessary, it can be used to plot generated samples into the terminal during training. Having direct feedback, instead of looking at plots in a separate window, use fantastic for debugging.</p><p>Next, let us define values for learning rate, batch size, epochs, and other hyper-parameters. While we are at it, we also define optimisers for the generator and discriminator network. More on what these are later.</p><pre><code class="language-julia hljs">    lr_g = 2e-4          # Learning rate of the generator network
    lr_d = 2e-4          # Learning rate of the discriminator network
    batch_size = 128    # batch size
    num_epochs = 1000   # Number of epochs to train for
    output_period = 100 # Period length for plots of generator samples
    n_features = 28 * 28# Number of pixels in each sample of the MNIST dataset
    latent_dim = 100    # Dimension of latent space
    opt_dscr = ADAM(lr_d)# Optimiser for the discriminator
    opt_gen = ADAM(lr_g) # Optimiser for the generator</code></pre><p>In this tutorial I&#39;m assuming that a CUDA-enabled GPU is available on the system where the script is running. If this is not the case, simply remove the <code>|&gt;gpu</code> decorators: <a href="https://docs.julialang.org/en/v1/manual/functions/#Function-composition-and-piping">piping</a>.</p><h2 id="Data-loading"><a class="docs-heading-anchor" href="#Data-loading">Data loading</a><a id="Data-loading-1"></a><a class="docs-heading-anchor-permalink" href="#Data-loading" title="Permalink"></a></h2><p>The MNIST data set is available from <a href="https://juliaml.github.io/MLDatasets.jl/latest/">MLDatasets</a>. The first time you instantiate it you will be prompted if you want to download it. You should agree to this. </p><p>GANs can be trained unsupervised. Therefore only keep the images from the training set and discard the labels.</p><p>After we load the training data we re-scale the data from values in [0:1] to values in [-1:1]. GANs are notoriously tricky to train and this re-scaling is a recommended <a href="https://github.com/soumith/ganhacks">GAN hack</a>. The  re-scaled data is used to define a data loader which handles batching and shuffling the data.</p><pre><code class="language-julia hljs">    # Load the dataset
    train_x, _ = MNIST.traindata(Float32);
    # This dataset has pixel values ∈ [0:1]. Map these to [-1:1]
    train_x = 2f0 * reshape(train_x, 28, 28, 1, :) .- 1f0 |&gt;gpu;
    # DataLoader allows to access data batch-wise and handles shuffling.
    train_loader = DataLoader(train_x, batchsize=batch_size, shuffle=true);</code></pre><h2 id="Defining-the-Networks"><a class="docs-heading-anchor" href="#Defining-the-Networks">Defining the Networks</a><a id="Defining-the-Networks-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Networks" title="Permalink"></a></h2><p>A vanilla GAN, the discriminator and the generator are both plain, <a href="https://boostedml.com/2020/04/feedforward-neural-networks-and-multilayer-perceptrons.html">feed-forward  multilayer perceptrons</a>. We use leaky rectified linear units <a href="https://fluxml.ai/Flux.jl/stable/models/nnlib/#NNlib.leakyrelu">leakyrelu</a> to ensure out model is non-linear. </p><p>Here, the coefficient <code>α</code> (in the <code>leakyrelu</code> below), is set to 0.2. Empirically,   this value allows for good training of the network (based on prior experiments).  It has also been found that Dropout ensures a good generalization of the learned  network, so we will use that below. Dropout is usually active when training a  model and inactive in inference. Flux automatically sets the training mode when calling the model in a gradient context. As a final non-linearity, we use the <code>sigmoid</code> activation function.</p><pre><code class="language-julia hljs">discriminator = Chain(Dense(n_features, 1024, x -&gt; leakyrelu(x, 0.2f0)),
                        Dropout(0.3),
                        Dense(1024, 512, x -&gt; leakyrelu(x, 0.2f0)),
                        Dropout(0.3),
                        Dense(512, 256, x -&gt; leakyrelu(x, 0.2f0)),
                        Dropout(0.3),
                        Dense(256, 1, sigmoid)) |&gt; gpu</code></pre><p>Let&#39;s define the generator in a similar fashion. This network maps a latent variable (a variable that is not directly observed but instead inferred) to the  image space and we set the input and output dimension accordingly. A <code>tanh</code> squashes  the output of the final layer to values in [-1:1], the same range that we squashed  the training data onto.</p><pre><code class="language-julia hljs">generator = Chain(Dense(latent_dim, 256, x -&gt; leakyrelu(x, 0.2f0)),
                    Dense(256, 512, x -&gt; leakyrelu(x, 0.2f0)),
                    Dense(512, 1024, x -&gt; leakyrelu(x, 0.2f0)),
                    Dense(1024, n_features, tanh)) |&gt; gpu</code></pre><h2 id="Training-functions-for-the-networks"><a class="docs-heading-anchor" href="#Training-functions-for-the-networks">Training functions for the networks</a><a id="Training-functions-for-the-networks-1"></a><a class="docs-heading-anchor-permalink" href="#Training-functions-for-the-networks" title="Permalink"></a></h2><p>To train the discriminator, we present it with real data from the MNIST data set and with fake data and reward it by predicting the correct labels for each sample. The correct labels are of course 1 for in-distribution data and 0 for out-of-distribution data coming from the generator.  <a href="https://fluxml.ai/Flux.jl/stable/models/losses/#Flux.Losses.binarycrossentropy">Binary cross entropy</a> is the loss function of choice. While the Flux documentation suggests to use <a href="https://fluxml.ai/Flux.jl/stable/models/losses/#Flux.Losses.logitcrossentropy">Logit binary cross entropy</a>, the GAN seems to be difficult to train with this loss function. This function returns the discriminator loss for logging purposes. We can calculate the loss in the same call as evaluating the pullback and resort to getting the pullback directly from Zygote instead of calling <code>Flux.train!</code> on the model. To calculate the gradients of the loss function with respect to the parameters of the discriminator we then only have to evaluate the pullback with a seed gradient of 1.0. These gradients are used to update the model parameters</p><pre><code class="language-julia hljs">function train_dscr!(discriminator, real_data, fake_data)
    this_batch = size(real_data)[end] # Number of samples in the batch
    # Concatenate real and fake data into one big vector
    all_data = hcat(real_data, fake_data)

    # Target vector for predictions: 1 for real data, 0 for fake data.
    all_target = [ones(eltype(real_data), 1, this_batch) zeros(eltype(fake_data), 1, this_batch)] |&gt; gpu;

    ps = Flux.params(discriminator)
    loss, pullback = Zygote.pullback(ps) do
        preds = discriminator(all_data)
        loss = Flux.Losses.binarycrossentropy(preds, all_target)
    end
    # To get the gradients we evaluate the pullback with 1.0 as a seed gradient.
    grads = pullback(1f0)

    # Update the parameters of the discriminator with the gradients we calculated above
    Flux.update!(opt_dscr, Flux.params(discriminator), grads)
    
    return loss 
end</code></pre><p>Now we need to define a function to train the generator network. The job of the generator is to fool the discriminator so we reward the generator when the discriminator predicts a high probability for its samples to be real data. In the training function we first need to sample some noise, i.e. normally distributed data. This has to be done outside the pullback since we don&#39;t want to get the gradients with respect to the noise, but to the generator parameters. Inside the pullback we need to first apply the generator to the noise since we will take the gradient with respect to the parameters of the generator. We also need to call the discriminator in order to evaluate the loss function inside the pullback. Here we need to remember to deactivate the dropout layers of the discriminator. We do this by setting the discriminator into test mode before the pullback. Immediately after the pullback we set it back into training mode. Then we evaluate the pullback, call it with a seed gradient of 1.0 as above, update the parameters of the generator network and return the loss.</p><pre><code class="language-julia hljs">function train_gen!(discriminator, generator)
    # Sample noise
    noise = randn(latent_dim, batch_size) |&gt; gpu;

    # Define parameters and get the pullback
    ps = Flux.params(generator)
    # Set discriminator into test mode to disable dropout layers
    testmode!(discriminator)
    # Evaluate the loss function while calculating the pullback. We get the loss for free
    loss, back = Zygote.pullback(ps) do
        preds = discriminator(generator(noise));
        loss = Flux.Losses.binarycrossentropy(preds, 1.) 
    end
    # Evaluate the pullback with a seed-gradient of 1.0 to get the gradients for
    # the parameters of the generator
    grads = back(1.0f0)
    Flux.update!(opt_gen, Flux.params(generator), grads)
    # Set discriminator back into automatic mode
    trainmode!(discriminator, mode=:auto)
    return loss
end</code></pre><h2 id="Training"><a class="docs-heading-anchor" href="#Training">Training</a><a id="Training-1"></a><a class="docs-heading-anchor-permalink" href="#Training" title="Permalink"></a></h2><p>Now we are ready to train the GAN. In the training loop we keep track of the per-sample loss of the generator and the discriminator, where we use the batch loss returned by the two training functions defined above. In each epoch we iterate over the mini-batches given by the data loader. Only minimal data processing needs to be done before the training functions can be called. </p><pre><code class="language-julia hljs">lossvec_gen = zeros(num_epochs)
lossvec_dscr = zeros(num_epochs)

for n in 1:num_epochs
    loss_sum_gen = 0.0f0
    loss_sum_dscr = 0.0f0

    for x in train_loader
        # - Flatten the images from 28x28xbatchsize to 784xbatchsize
        real_data = flatten(x);

        # Train the discriminator
        noise = randn(latent_dim, size(x)[end]) |&gt; gpu
        fake_data = generator(noise)
        loss_dscr = train_dscr!(discriminator, real_data, fake_data)
        loss_sum_dscr += loss_dscr

        # Train the generator
        loss_gen = train_gen!(discriminator, generator)
        loss_sum_gen += loss_gen
    end

    # Add the per-sample loss of the generator and discriminator
    lossvec_gen[n] = loss_sum_gen / size(train_x)[end]
    lossvec_dscr[n] = loss_sum_dscr / size(train_x)[end]

    if n % output_period == 0
        @show n
        noise = randn(latent_dim, 4) |&gt; gpu;
        fake_data = reshape(generator(noise), 28, 4*28);
        p = heatmap(fake_data, colormap=:inferno)
        print(p)
    end
end </code></pre><p>For the hyper-parameters shown in this example, the generator produces useful images after about 1000 epochs. And after about 5000 epochs the result look indistinguishable from real MNIST data. Using a Nvidia V100 GPU on a 2.7 GHz Power9 CPU with 32 hardware threads, training 100 epochs takes about 80 seconds when using the GPU. The GPU utilization is between 30 and 40%. To observe the network more frequently during training you can for example set  <code>output_period=20</code>. Training the GAN using the CPU takes about 10 minutes  per epoch and is not recommended.</p><h2 id="Results"><a class="docs-heading-anchor" href="#Results">Results</a><a id="Results-1"></a><a class="docs-heading-anchor-permalink" href="#Results" title="Permalink"></a></h2><p>Below you can see what some of the images output may look like after different numbers of epochs.</p><p><img src="https://user-images.githubusercontent.com/35577566/138465727-3729b867-2c2c-4f12-ba8e-e7b00c73d82c.png" alt/></p><p><img src="https://user-images.githubusercontent.com/35577566/138465750-423f70fc-c8e7-489c-8cf4-f01b203a24dd.png" alt/></p><p><img src="https://user-images.githubusercontent.com/35577566/138465777-5c8252ae-e43b-4708-a42a-b0b85324f79d.png" alt/></p><p><img src="https://user-images.githubusercontent.com/35577566/138465803-07239e62-9e68-42b7-9bb7-57fdff748ba9.png" alt/></p><h2 id="Resources"><a class="docs-heading-anchor" href="#Resources">Resources</a><a id="Resources-1"></a><a class="docs-heading-anchor-permalink" href="#Resources" title="Permalink"></a></h2><ul><li><a href="https://github.com/AdarshKumar712/FluxGAN">A collection of GANs in Flux</a></li><li><a href="https://en.wikipedia.org/wiki/Generative_adversarial_network">Wikipedia</a></li><li><a href="https://github.com/soumith/ganhacks">GAN hacks</a></li></ul><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Originally published at <a href="https://fluxml.ai/tutorials/">fluxml.ai</a> on 14 October 2021, by Ralph Kube.</p></div></div></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 8 January 2024 22:01">Monday 8 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
