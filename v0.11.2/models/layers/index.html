<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Model Reference · Flux</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-36890222-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script data-main="../../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/flux.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-dark" href="../../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../../assets/themeswap.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Flux</span></div><form action="../../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Building Models</span><ul><li><a class="tocitem" href="../basics/">Basics</a></li><li><a class="tocitem" href="../recurrence/">Recurrence</a></li><li class="is-active"><a class="tocitem" href="">Model Reference</a><ul class="internal"><li><a class="tocitem" href="#Basic-Layers-1"><span>Basic Layers</span></a></li><li><a class="tocitem" href="#Convolution-and-Pooling-Layers-1"><span>Convolution and Pooling Layers</span></a></li><li><a class="tocitem" href="#Recurrent-Layers-1"><span>Recurrent Layers</span></a></li><li><a class="tocitem" href="#Other-General-Purpose-Layers-1"><span>Other General Purpose Layers</span></a></li><li><a class="tocitem" href="#Normalisation-and-Regularisation-1"><span>Normalisation &amp; Regularisation</span></a></li></ul></li><li><a class="tocitem" href="../losses/">Loss Functions</a></li><li><a class="tocitem" href="../regularisation/">Regularisation</a></li><li><a class="tocitem" href="../advanced/">Advanced Model Building</a></li><li><a class="tocitem" href="../nnlib/">NNlib</a></li></ul></li><li><span class="tocitem">Handling Data</span><ul><li><a class="tocitem" href="../../data/onehot/">One-Hot Encoding</a></li><li><a class="tocitem" href="../../data/dataloader/">DataLoader</a></li></ul></li><li><span class="tocitem">Training Models</span><ul><li><a class="tocitem" href="../../training/optimisers/">Optimisers</a></li><li><a class="tocitem" href="../../training/training/">Training</a></li></ul></li><li><a class="tocitem" href="../../gpu/">GPU Support</a></li><li><a class="tocitem" href="../../saving/">Saving &amp; Loading</a></li><li><a class="tocitem" href="../../ecosystem/">The Julia Ecosystem</a></li><li><a class="tocitem" href="../../utilities/">Utility Functions</a></li><li><a class="tocitem" href="../../performance/">Performance Tips</a></li><li><a class="tocitem" href="../../datasets/">Datasets</a></li><li><a class="tocitem" href="../../community/">Community</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Building Models</a></li><li class="is-active"><a href="">Model Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Model Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FluxML/Flux.jl/blob/master/docs/src/models/layers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h2 id="Basic-Layers-1"><a class="docs-heading-anchor" href="#Basic-Layers-1">Basic Layers</a><a class="docs-heading-anchor-permalink" href="#Basic-Layers-1" title="Permalink"></a></h2><p>These core layers form the foundation of almost all neural networks.</p><article class="docstring"><header><a class="docstring-binding" href="#Flux.Chain" id="Flux.Chain"><code>Flux.Chain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Chain(layers...)</code></pre><p>Chain multiple layers / functions together, so that they are called in sequence on a given input.</p><p><code>Chain</code> also supports indexing and slicing, e.g. <code>m[2]</code> or <code>m[1:end-1]</code>. <code>m[1:3](x)</code> will calculate the output of the first three layers.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; m = Chain(x -&gt; x^2, x -&gt; x+1);

julia&gt; m(5) == 26
true

julia&gt; m = Chain(Dense(10, 5), Dense(5, 2));

julia&gt; x = rand(10);

julia&gt; m(x) == m[2](m[1](x))
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/basic.jl#L1-L24" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.Dense" id="Flux.Dense"><code>Flux.Dense</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Dense(in::Integer, out::Integer, σ = identity)</code></pre><p>Create a traditional <code>Dense</code> layer with parameters <code>W</code> and <code>b</code>.</p><pre><code class="language-none">y = σ.(W * x .+ b)</code></pre><p>The input <code>x</code> must be a vector of length <code>in</code>, or a batch of vectors represented as an <code>in × N</code> matrix. The out <code>y</code> will be a vector or batch of length <code>out</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; d = Dense(5, 2)
Dense(5, 2)

julia&gt; d(rand(5))
2-element Array{Float32,1}:
 -0.16210233
  0.123119034</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/basic.jl#L85-L105" target="_blank">source</a></section></article><h2 id="Convolution-and-Pooling-Layers-1"><a class="docs-heading-anchor" href="#Convolution-and-Pooling-Layers-1">Convolution and Pooling Layers</a><a class="docs-heading-anchor-permalink" href="#Convolution-and-Pooling-Layers-1" title="Permalink"></a></h2><p>These layers are used to build convolutional neural networks (CNNs).</p><article class="docstring"><header><a class="docstring-binding" href="#Flux.Conv" id="Flux.Conv"><code>Flux.Conv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Conv(filter, in =&gt; out, σ = identity; init = glorot_uniform,
     stride = 1, pad = 0, dilation = 1)

filter = (2,2)
in = 1
out = 16
Conv((2, 2), 1=&gt;16, relu)</code></pre><p>Standard convolutional layer. <code>filter</code> should be a tuple like <code>(2, 2)</code>. <code>in</code> and <code>out</code> specify the number of input and output channels respectively.</p><p>Data should be stored in WHCN order (width, height, # channels, batch size). In other words, a 100×100 RGB image would be a <code>100×100×3×1</code> array, and a batch of 50 would be a <code>100×100×3×50</code> array.</p><p>Accepts keyword arguments <code>weight</code> and <code>bias</code> to set the corresponding fields. Setting <code>bias</code> to <code>Flux.Zeros()</code> will switch bias off for the layer.</p><p>Takes the keyword arguments <code>pad</code>, <code>stride</code> and <code>dilation</code>. For input dimension N, <code>pad</code> should be a single Integer indicating equal padding value for each spatial dimension, a tuple of length (N-2) to apply symmetric padding or a tuple of length 2*(N-2) indicating padding values for each spatial dimension at both the ends. <code>stride</code> and <code>dilation</code> should be a single Integer or a tuple with N-2 parameters. Use <code>pad=SamePad()</code> to apply padding so that outputsize == inputsize / stride.</p><p><strong>Examples</strong></p><p>Apply a <code>Conv</code> layer to a 1-channel input using a 2×2 window filter size, giving us a 16-channel output. Output is activated with ReLU.</p><pre><code class="language-julia">filter = (2,2)
in = 1
out = 16
Conv(filter, in =&gt; out, relu)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/conv.jl#L32-L69" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.AdaptiveMaxPool" id="Flux.AdaptiveMaxPool"><code>Flux.AdaptiveMaxPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AdaptiveMaxPool(out)</code></pre><p>Adaptive max pooling layer. <code>out</code> is the desired output size (batch and channel dimension excluded).</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/conv.jl#L527-L531" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.MaxPool" id="Flux.MaxPool"><code>Flux.MaxPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MaxPool(k; pad = 0, stride = k)</code></pre><p>Max pooling layer. <code>k</code> is the size of the window for each dimension of the input.</p><p><strong>Use <code>pad=SamePad()</code> to apply padding so that outputsize == inputsize / stride.</strong></p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/conv.jl#L625-L632" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.GlobalMaxPool" id="Flux.GlobalMaxPool"><code>Flux.GlobalMaxPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GlobalMaxPool()</code></pre><p>Global max pooling layer.</p><p>Transforms (w,h,c,b)-shaped input into (1,1,c,b)-shaped output, by performing max pooling on the complete (w,h)-shaped feature maps.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/conv.jl#L575-L582" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.AdaptiveMeanPool" id="Flux.AdaptiveMeanPool"><code>Flux.AdaptiveMeanPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AdaptiveMeanPool(out)</code></pre><p>Adaptive mean pooling layer. <code>out</code> is the desired output size (batch and channel dimension excluded).</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/conv.jl#L551-L555" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.MeanPool" id="Flux.MeanPool"><code>Flux.MeanPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MeanPool(k; pad = 0, stride = k)</code></pre><p>Mean pooling layer. <code>k</code> is the size of the window for each dimension of the input.</p><p>Use <code>pad=SamePad()</code> to apply padding so that outputsize == inputsize / stride.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/conv.jl#L656-L662" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.GlobalMeanPool" id="Flux.GlobalMeanPool"><code>Flux.GlobalMeanPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GlobalMeanPool()</code></pre><p>Global mean pooling layer.</p><p>Transforms (w,h,c,b)-shaped input into (1,1,c,b)-shaped output, by performing mean pooling on the complete (w,h)-shaped feature maps.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/conv.jl#L600-L607" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.DepthwiseConv" id="Flux.DepthwiseConv"><code>Flux.DepthwiseConv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DepthwiseConv(filter::Tuple, in=&gt;out)
DepthwiseConv(filter::Tuple, in=&gt;out, activation)
DepthwiseConv(filter, in =&gt; out, σ = identity; init = glorot_uniform,
              stride = 1, pad = 0, dilation = 1)</code></pre><p>Depthwise convolutional layer. <code>filter</code> should be a tuple like <code>(2, 2)</code>. <code>in</code> and <code>out</code> specify the number of input and output channels respectively. Note that <code>out</code> must be an integer multiple of <code>in</code>.</p><p>Data should be stored in WHCN order (width, height, # channels, batch size). In other words, a 100×100 RGB image would be a <code>100×100×3×1</code> array, and a batch of 50 would be a <code>100×100×3×50</code> array.</p><p>Accepts keyword arguments <code>weight</code> and <code>bias</code> to set the corresponding fields. Setting <code>bias</code> to <code>Flux.Zeros()</code> will switch bias off for the layer.</p><p>Takes the keyword arguments <code>pad</code>, <code>stride</code> and <code>dilation</code>. For input dimension N, <code>pad</code> should be a single Integer indicating equal padding value for each spatial dimension, a tuple of length (N-2) to apply symmetric padding or a tuple of length 2*(N-2) indicating padding values for each spatial dimension at both the ends. <code>stride</code> and <code>dilation</code> should be a single Integer or a tuple with N-2 parameters. Use <code>pad=SamePad()</code> to apply padding so that outputsize == inputsize / stride.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/conv.jl#L295-L319" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.ConvTranspose" id="Flux.ConvTranspose"><code>Flux.ConvTranspose</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConvTranspose(filter, in=&gt;out)
ConvTranspose(filter, in=&gt;out, activation)
ConvTranspose(filter, in =&gt; out, σ = identity; init = glorot_uniform,
              stride = 1, pad = 0, dilation = 1)</code></pre><p>Standard convolutional transpose layer. <code>filter</code> should be a tuple like <code>(2, 2)</code>. <code>in</code> and <code>out</code> specify the number of input and output channels respectively.</p><p>Data should be stored in WHCN order (width, height, # channels, batch size). In other words, a 100×100 RGB image would be a <code>100×100×3×1</code> array, and a batch of 50 would be a <code>100×100×3×50</code> array.</p><p>Accepts keyword arguments <code>weight</code> and <code>bias</code> to set the corresponding fields. Setting <code>bias</code> to <code>Flux.Zeros()</code> will switch bias off for the layer.</p><p>Takes the keyword arguments <code>pad</code>, <code>stride</code> and <code>dilation</code>. For input dimension N, <code>pad</code> should be a single Integer indicating equal padding value for each spatial dimension, a tuple of length (N-2) to apply symmetric padding or a tuple of length 2*(N-2) indicating padding values for each spatial dimension at both the ends. <code>stride</code> and <code>dilation</code> should be a single Integer or a tuple with N-2 parameters. Use <code>pad=SamePad()</code> to apply padding so that outputsize == stride * inputsize.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/conv.jl#L178-L201" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.CrossCor" id="Flux.CrossCor"><code>Flux.CrossCor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CrossCor(filter, in=&gt;out)
CrossCor(filter, in=&gt;out, activation)
CrossCor(filter, in =&gt; out, σ = identity; init = glorot_uniform,
         stride = 1, pad = 0, dilation = 1)</code></pre><p>Standard cross convolutional layer. <code>filter</code> should be a tuple like <code>(2, 2)</code>. <code>in</code> and <code>out</code> specify the number of input and output channels respectively.</p><p>Data should be stored in WHCN order (width, height, # channels, batch size). In other words, a 100×100 RGB image would be a <code>100×100×3×1</code> array, and a batch of 50 would be a <code>100×100×3×50</code> array.</p><p>Accepts keyword arguments <code>weight</code> and <code>bias</code> to set the corresponding fields. Setting <code>bias</code> to <code>Flux.Zeros()</code> will switch bias off for the layer.</p><p>Takes the keyword arguments <code>pad</code>, <code>stride</code> and <code>dilation</code>. For input dimension N, <code>pad</code> should be a single Integer indicating equal padding value for each spatial dimension, a tuple of length (N-2) to apply symmetric padding or a tuple of length 2*(N-2) indicating padding values for each spatial dimension at both the ends. <code>stride</code> and <code>dilation</code> should be a single Integer or a tuple with N-2 parameters. Use <code>pad=SamePad()</code> to apply padding so that outputsize == inputsize / stride.</p><p><strong>Examples</strong></p><p>Apply a <code>CrossCor</code> layer to a 1-channel input using a 2×2 window filter size, giving us a 16-channel output. Output is activated with ReLU.</p><pre><code class="language-julia">filter = (2,2)
in = 1
out = 16
CrossCor((2, 2), 1=&gt;16, relu)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/conv.jl#L413-L447" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.SamePad" id="Flux.SamePad"><code>Flux.SamePad</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SamePad</code></pre><p>Padding for convolutional layers will be calculated so that outputshape == inputshape when stride = 1.</p><p>For stride &gt; 1 the output shape depends on the type of convolution layer.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/conv.jl#L11-L17" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.flatten" id="Flux.flatten"><code>Flux.flatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">flatten(x::AbstractArray)</code></pre><p>Reshape arbitrarly-shaped input into a matrix-shaped output preserving the last dimension size. Equivalent to <code>reshape(x, :, size(x)[end])</code>.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/stateless.jl#L1-L7" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.Zeros" id="Flux.Zeros"><code>Flux.Zeros</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Zeros()
Zeros(size...)
Zeros(Type, size...)</code></pre><p>Acts as a stand-in for an array of zeros that can be used during training which is ignored by the optimisers.</p><p>Useful to turn bias off for a forward pass of a layer.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; Flux.Zeros(3,3)
3×3 Flux.Zeros{Bool,2}:
 false  false  false
 false  false  false
 false  false  false

julia&gt; Flux.Zeros(Float32, 3,3)
3×3 Flux.Zeros{Float32,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0

julia&gt; rand(3,3) .+ Flux.Zeros()
3×3 Array{Float64,2}:
 0.198739  0.490459  0.785386
 0.779074  0.39986   0.66383
 0.854981  0.447292  0.314497

julia&gt; bias_less_conv = Conv((2,2), 1=&gt;3, bias = Flux.Zeros())
Conv((2, 2), 1=&gt;3)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/zeros.jl#L4-L38" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.convfilter" id="Flux.convfilter"><code>Flux.convfilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">convfilter(filter::Tuple, in=&gt;out)</code></pre><p>Constructs a standard convolutional weight matrix with given <code>filter</code> and channels from <code>in</code> to <code>out</code>.</p><p>Accepts the keyword <code>init</code> (default: <code>glorot_uniform</code>) to control the sampling distribution.</p><p>See also: <a href="#Flux.depthwiseconvfilter"><code>depthwiseconvfilter</code></a></p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/conv.jl#L118-L128" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.depthwiseconvfilter" id="Flux.depthwiseconvfilter"><code>Flux.depthwiseconvfilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">depthwiseconvfilter(filter::Tuple, in=&gt;out)</code></pre><p>Constructs a depthwise convolutional weight array defined by <code>filter</code> and channels from <code>in</code> to <code>out</code>.</p><p>Accepts the keyword <code>init</code> (default: <code>glorot_uniform</code>) to control the sampling distribution.</p><p>See also: <a href="#Flux.convfilter"><code>convfilter</code></a></p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/conv.jl#L360-L370" target="_blank">source</a></section></article><h2 id="Recurrent-Layers-1"><a class="docs-heading-anchor" href="#Recurrent-Layers-1">Recurrent Layers</a><a class="docs-heading-anchor-permalink" href="#Recurrent-Layers-1" title="Permalink"></a></h2><p>Much like the core layers above, but can be used to process sequence data (as well as other kinds of structured data).</p><article class="docstring"><header><a class="docstring-binding" href="#Flux.RNN" id="Flux.RNN"><code>Flux.RNN</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RNN(in::Integer, out::Integer, σ = tanh)</code></pre><p>The most basic recurrent layer; essentially acts as a <code>Dense</code> layer, but with the output fed back into the input each time step.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/recurrent.jl#L91-L96" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.LSTM" id="Flux.LSTM"><code>Flux.LSTM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">LSTM(in::Integer, out::Integer)</code></pre><p><a href="https://www.researchgate.net/publication/13853244_Long_Short-term_Memory">Long Short Term Memory</a> recurrent layer. Behaves like an RNN but generally exhibits a longer memory span over sequences.</p><p>See <a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">this article</a> for a good overview of the internals.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/recurrent.jl#L136-L144" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.GRU" id="Flux.GRU"><code>Flux.GRU</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">GRU(in::Integer, out::Integer)</code></pre><p><a href="https://arxiv.org/abs/1406.1078">Gated Recurrent Unit</a> layer. Behaves like an RNN but generally exhibits a longer memory span over sequences.</p><p>See <a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">this article</a> for a good overview of the internals.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/recurrent.jl#L177-L185" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.Recur" id="Flux.Recur"><code>Flux.Recur</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Recur(cell)</code></pre><p><code>Recur</code> takes a recurrent cell and makes it stateful, managing the hidden state in the background. <code>cell</code> should be a model of the form:</p><pre><code class="language-none">h, y = cell(h, x...)</code></pre><p>For example, here's a recurrent network that keeps a running total of its inputs:</p><pre><code class="language-julia">accum(h, x) = (h + x, x)
rnn = Flux.Recur(accum, 0)
rnn(2)      # 2
rnn(3)      # 3
rnn.state   # 5
rnn.(1:10)  # apply to a sequence
rnn.state   # 60</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/recurrent.jl#L7-L26" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.reset!" id="Flux.reset!"><code>Flux.reset!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reset!(rnn)</code></pre><p>Reset the hidden state of a recurrent layer back to its original value.</p><p>Assuming you have a <code>Recur</code> layer <code>rnn</code>, this is roughly equivalent to:</p><pre><code class="language-julia">rnn.state = hidden(rnn.cell)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/recurrent.jl#L45-L54" target="_blank">source</a></section></article><h2 id="Other-General-Purpose-Layers-1"><a class="docs-heading-anchor" href="#Other-General-Purpose-Layers-1">Other General Purpose Layers</a><a class="docs-heading-anchor-permalink" href="#Other-General-Purpose-Layers-1" title="Permalink"></a></h2><p>These are marginally more obscure than the Basic Layers. But in contrast to the layers described in the other sections are not readily grouped around a particular purpose (e.g. CNNs or RNNs).</p><article class="docstring"><header><a class="docstring-binding" href="#Flux.Maxout" id="Flux.Maxout"><code>Flux.Maxout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Maxout(over)</code></pre><p>The <a href="https://arxiv.org/abs/1302.4389">Maxout</a> layer has a number of internal layers which all receive the same input. It returns the elementwise maximum of the internal layers' outputs.</p><p>Maxout over linear dense layers satisfies the univeral approximation theorem.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/basic.jl#L187-L195" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.SkipConnection" id="Flux.SkipConnection"><code>Flux.SkipConnection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SkipConnection(layer, connection)</code></pre><p>Create a skip connection which consists of a layer or <code>Chain</code> of consecutive layers and a shortcut connection linking the block's input to the output through a user-supplied 2-argument callable. The first argument to the callable will be propagated through the given <code>layer</code> while the second is the unchanged, "skipped" input.</p><p>The simplest "ResNet"-type connection is just <code>SkipConnection(layer, +)</code>, and requires the output of the layers to be the same shape as the input. Here is a more complicated example:</p><pre><code class="language-julia">m = Conv((3,3), 4=&gt;7, pad=(1,1))
x = ones(5,5,4,10);
size(m(x)) == (5, 5, 7, 10)

sm = SkipConnection(m, (mx, x) -&gt; cat(mx, x, dims=3))
size(sm(x)) == (5, 5, 11, 10)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/basic.jl#L230-L250" target="_blank">source</a></section></article><h2 id="Normalisation-and-Regularisation-1"><a class="docs-heading-anchor" href="#Normalisation-and-Regularisation-1">Normalisation &amp; Regularisation</a><a class="docs-heading-anchor-permalink" href="#Normalisation-and-Regularisation-1" title="Permalink"></a></h2><p>These layers don't affect the structure of the network but may improve training times or reduce overfitting.</p><article class="docstring"><header><a class="docstring-binding" href="#Flux.normalise" id="Flux.normalise"><code>Flux.normalise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalise(x; dims, ϵ=1e-5)</code></pre><p>Normalise <code>x</code> to mean 0 and standard deviation 1 across the dimensions given by <code>dims</code>. <code>ϵ</code> is a small additive factor added to the denominator for numerical stability.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/stateless.jl#L14-L19" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.BatchNorm" id="Flux.BatchNorm"><code>Flux.BatchNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BatchNorm(channels::Integer, σ = identity;
          initβ = zeros, initγ = ones,
          ϵ = 1e-8, momentum = .1)</code></pre><p><a href="https://arxiv.org/abs/1502.03167">Batch Normalization</a> layer. <code>channels</code> should be the size of the channel dimension in your data (see below).</p><p>Given an array with <code>N</code> dimensions, call the <code>N-1</code>th the channel dimension. (For a batch of feature vectors this is just the data dimension, for <code>WHCN</code> images it's the usual channel dimension.)</p><p><code>BatchNorm</code> computes the mean and variance for each each <code>W×H×1×N</code> slice and shifts them to have a new mean and variance (corresponding to the learnable, per-channel <code>bias</code> and <code>scale</code> parameters).</p><p>Use <a href="#Flux.testmode!"><code>testmode!</code></a> during inference.</p><p><strong>Examples</strong></p><pre><code class="language-julia">m = Chain(
  Dense(28^2, 64),
  BatchNorm(64, relu),
  Dense(64, 10),
  BatchNorm(10),
  softmax)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/normalise.jl#L143-L170" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.dropout" id="Flux.dropout"><code>Flux.dropout</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dropout(x, p; dims=:, active::Bool)</code></pre><p>The dropout function. If <code>active</code> is <code>true</code>, for each input, either sets that input to <code>0</code> (with probability <code>p</code>) or scales it by <code>1 / (1 - p)</code>. <code>dims</code> specifies the unbroadcasted dimensions, e.g. <code>dims=1</code> applies dropout along columns and <code>dims=2</code> along rows. This is used as a regularisation, i.e. it reduces overfitting during training.</p><p>If <code>active</code> is <code>false</code>, it just returns the input <code>x</code></p><p>Warning: when using this function, you have to manually manage the activation state. Usually in fact, dropout is used while training but is deactivated in the inference phase. This can be automatically managed using the <a href="#Flux.Dropout"><code>Dropout</code></a> layer instead of the <code>dropout</code> function.</p><p>The <a href="#Flux.Dropout"><code>Dropout</code></a> layer is what you should use in most scenarios.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/normalise.jl#L14-L32" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.Dropout" id="Flux.Dropout"><code>Flux.Dropout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Dropout(p, dims = :)</code></pre><p>Dropout layer. In the forward pass, apply the <a href="#Flux.dropout"><code>Flux.dropout</code></a> function on the input.</p><p>Does nothing to the input once <a href="#Flux.testmode!"><code>Flux.testmode!</code></a> is <code>true</code>.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/normalise.jl#L51-L57" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.AlphaDropout" id="Flux.AlphaDropout"><code>Flux.AlphaDropout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AlphaDropout(p)</code></pre><p>A dropout layer. Used in <a href="https://arxiv.org/abs/1706.02515">Self-Normalizing Neural Networks</a>. The AlphaDropout layer ensures that mean and variance of activations remain the same as before.</p><p>Does nothing to the input once <a href="#Flux.testmode!"><code>testmode!</code></a> is true.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/normalise.jl#L86-L95" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.LayerNorm" id="Flux.LayerNorm"><code>Flux.LayerNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LayerNorm(h::Integer)</code></pre><p>A <a href="https://arxiv.org/abs/1607.06450">normalisation layer</a> designed to be used with recurrent hidden states of size <code>h</code>. Normalises the mean and standard deviation of each input before applying a per-neuron gain/bias.</p></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/normalise.jl#L121-L127" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.InstanceNorm" id="Flux.InstanceNorm"><code>Flux.InstanceNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InstanceNorm(channels::Integer, σ = identity;
             initβ = zeros, initγ = ones,
             ϵ = 1e-8, momentum = .1)</code></pre><p><a href="https://arxiv.org/abs/1607.08022">Instance Normalization</a> layer. <code>channels</code> should be the size of the channel dimension in your data (see below).</p><p>Given an array with <code>N</code> dimensions, call the <code>N-1</code>th the channel dimension. (For a batch of feature vectors this is just the data dimension, for <code>WHCN</code> images it's the usual channel dimension.)</p><p><code>InstanceNorm</code> computes the mean and variance for each each <code>W×H×1×1</code> slice and shifts them to have a new mean and variance (corresponding to the learnable, per-channel <code>bias</code> and <code>scale</code> parameters).</p><p>Use <a href="#Flux.testmode!"><code>testmode!</code></a> during inference.</p><p><strong>Examples</strong></p><pre><code class="language-julia">m = Chain(
  Dense(28^2, 64),
  InstanceNorm(64, relu),
  Dense(64, 10),
  InstanceNorm(10),
  softmax)</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/normalise.jl#L249-L276" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.GroupNorm" id="Flux.GroupNorm"><code>Flux.GroupNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GroupNorm(chs::Integer, G::Integer, λ = identity;
          initβ = (i) -&gt; zeros(Float32, i), initγ = (i) -&gt; ones(Float32, i),
          ϵ = 1f-5, momentum = 0.1f0)</code></pre><p><a href="https://arxiv.org/abs/1803.08494">Group Normalization</a> layer. This layer can outperform Batch Normalization and Instance Normalization.</p><p><code>chs</code> is the number of channels, the channel dimension of your input. For an array of N dimensions, the <code>N-1</code>th index is the channel dimension.</p><p><code>G</code> is the number of groups along which the statistics are computed. The number of channels must be an integer multiple of the number of groups.</p><p>Use <a href="#Flux.testmode!"><code>testmode!</code></a> during inference.</p><p><strong>Examples</strong></p><pre><code class="language-julia">m = Chain(Conv((3,3), 1=&gt;32, leakyrelu;pad = 1),
          GroupNorm(32,16))
          # 32 channels, 16 groups (G = 16), thus 2 channels per group used</code></pre></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/layers/normalise.jl#L334-L356" target="_blank">source</a></section></article><h3 id="Testmode-1"><a class="docs-heading-anchor" href="#Testmode-1">Testmode</a><a class="docs-heading-anchor-permalink" href="#Testmode-1" title="Permalink"></a></h3><p>Many normalisation layers behave differently under training and inference (testing). By default, Flux will automatically determine when a layer evaluation is part of training or inference. Still, depending on your use case, it may be helpful to manually specify when these layers should be treated as being trained or not. For this, Flux provides <code>Flux.testmode!</code>. When called on a model (e.g. a layer or chain of layers), this function will place the model into the mode specified.</p><article class="docstring"><header><a class="docstring-binding" href="#Flux.testmode!" id="Flux.testmode!"><code>Flux.testmode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">testmode!(m, mode = true)</code></pre><p>Set a layer or model's test mode (see below). Using <code>:auto</code> mode will treat any gradient computation as training.</p><p><em>Note</em>: if you manually set a model into test mode, you need to manually place it back into train mode during training phase.</p><p>Possible values include:</p><ul><li><code>false</code> for training</li><li><code>true</code> for testing</li><li><code>:auto</code> or <code>nothing</code> for Flux to detect the mode automatically</li></ul></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/functor.jl#L8-L21" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Flux.trainmode!" id="Flux.trainmode!"><code>Flux.trainmode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trainmode!(m, mode = true)</code></pre><p>Set a layer of model's train mode (see below). Symmetric to <a href="#Flux.testmode!"><code>testmode!</code></a> (i.e. <code>trainmode!(m, mode) == testmode!(m, !mode)</code>).</p><p><em>Note</em>: if you manually set a model into train mode, you need to manually place it into test mode during testing phase.</p><p>Possible values include:</p><ul><li><code>true</code> for training</li><li><code>false</code> for testing</li><li><code>:auto</code> or <code>nothing</code> for Flux to detect the mode automatically</li></ul></div><a class="docs-sourcelink" href="https://github.com/FluxML/Flux.jl/blob/8fb94be4a682fe6879368d55c26e50359c049703/src/functor.jl#L24-L37" target="_blank">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../recurrence/">« Recurrence</a><a class="docs-footer-nextpage" href="../losses/">Loss Functions »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 6 November 2020 10:42">Friday 6 November 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>