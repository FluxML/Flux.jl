<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GPU Support · Flux</title><meta name="title" content="GPU Support · Flux"/><meta property="og:title" content="GPU Support · Flux"/><meta property="twitter:title" content="GPU Support · Flux"/><meta name="description" content="Documentation for Flux."/><meta property="og:description" content="Documentation for Flux."/><meta property="twitter:description" content="Documentation for Flux."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-36890222-9"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-36890222-9', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/flux.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="Flux logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="Flux logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../models/quickstart/">Quick Start</a></li><li><a class="tocitem" href="../models/overview/">Fitting a Line</a></li><li><a class="tocitem" href="../models/basics/">Gradients and Layers</a></li><li><a class="tocitem" href="../models/custom_layers/">Custom Layers</a></li><li><a class="tocitem" href="../training/training/">Training</a></li><li><a class="tocitem" href="../models/recurrence/">Recurrence</a></li><li class="is-active"><a class="tocitem" href>GPU Support</a><ul class="internal"><li><a class="tocitem" href="#Checking-GPU-Availability"><span>Checking GPU Availability</span></a></li><li><a class="tocitem" href="#Selecting-GPU-backend"><span>Selecting GPU backend</span></a></li><li><a class="tocitem" href="#Basic-GPU-Usage"><span>Basic GPU Usage</span></a></li><li><a class="tocitem" href="#Transferring-Training-Data"><span>Transferring Training Data</span></a></li><li><a class="tocitem" href="#Saving-GPU-Trained-Models"><span>Saving GPU-Trained Models</span></a></li><li><a class="tocitem" href="#Disabling-CUDA-or-choosing-which-GPUs-are-visible-to-Flux"><span>Disabling CUDA or choosing which GPUs are visible to Flux</span></a></li><li><a class="tocitem" href="#Using-device-objects"><span>Using device objects</span></a></li><li><a class="tocitem" href="#Data-movement-across-GPU-devices"><span>Data movement across GPU devices</span></a></li><li><a class="tocitem" href="#Distributed-data-parallel-training"><span>Distributed data parallel training</span></a></li></ul></li><li><a class="tocitem" href="../saving/">Saving &amp; Loading</a></li><li><a class="tocitem" href="../performance/">Performance Tips</a></li></ul></li><li><a class="tocitem" href="../../ecosystem/">Ecosystem</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference/models/layers/">Built-in Layers</a></li><li><a class="tocitem" href="../../reference/models/activation/">Activation Functions</a></li><li><a class="tocitem" href="../../reference/utilities/">Weight Initialisation</a></li><li><a class="tocitem" href="../../reference/models/losses/">Loss Functions</a></li><li><a class="tocitem" href="../../reference/training/reference/">Training API</a></li><li><a class="tocitem" href="../../reference/training/optimisers/">Optimisation Rules</a></li><li><a class="tocitem" href="../../reference/outputsize/">Shape Inference</a></li><li><a class="tocitem" href="../../reference/destructure/">Flat vs. Nested</a></li><li><a class="tocitem" href="../../reference/training/callbacks/">Callback Helpers</a></li><li><a class="tocitem" href="../../reference/training/zygote/">Gradients – Zygote.jl</a></li><li><a class="tocitem" href="../../reference/data/mlutils/">Batching Data – MLUtils.jl</a></li><li><a class="tocitem" href="../../reference/data/onehot/">OneHotArrays.jl</a></li><li><a class="tocitem" href="../../reference/models/nnlib/">Low-level Operations – NNlib.jl</a></li><li><a class="tocitem" href="../../reference/models/functors/">Nested Structures – Functors.jl</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/linear_regression/">Linear Regression</a></li><li><a class="tocitem" href="../../tutorials/logistic_regression/">Logistic Regression</a></li><li><a class="tocitem" href="../../tutorials/model_zoo/">Model Zoo</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Guide</a></li><li class="is-active"><a href>GPU Support</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>GPU Support</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/FluxML/Flux.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/FluxML/Flux.jl/blob/master/docs/src/guide/gpu.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="GPU-Support"><a class="docs-heading-anchor" href="#GPU-Support">GPU Support</a><a id="GPU-Support-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-Support" title="Permalink"></a></h1><p>Starting with v0.14, Flux doesn&#39;t force a specific GPU backend and the corresponding package dependencies on the users.  Thanks to the <a href="https://pkgdocs.julialang.org/v1/creating-packages/#Conditional-loading-of-code-in-packages-(Extensions)">package extension mechanism</a> introduced in julia v1.9, Flux conditionally loads GPU specific code once a GPU package is made available (e.g. through <code>using CUDA</code>).</p><p>NVIDIA GPU support requires the packages <code>CUDA.jl</code> and <code>cuDNN.jl</code> to be installed in the environment. In the julia REPL, type <code>] add CUDA, cuDNN</code> to install them. For more details see the <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a> readme.</p><p>AMD GPU support is available since Julia 1.9 on systems with ROCm and MIOpen installed. For more details refer to the <a href="https://github.com/JuliaGPU/AMDGPU.jl">AMDGPU.jl</a> repository.</p><p>Metal GPU acceleration is available on Apple Silicon hardware. For more details refer to the <a href="https://github.com/JuliaGPU/Metal.jl">Metal.jl</a> repository. Metal support in Flux is experimental and many features are not yet available.</p><p>In order to trigger GPU support in Flux, you need to call <code>using CUDA</code>, <code>using AMDGPU</code> or <code>using Metal</code> in your code. Notice that for CUDA, explicitly loading also <code>cuDNN</code> is not required, but the package has to be installed in the environment. </p><div class="admonition is-compat"><header class="admonition-header">Flux ≤ 0.13</header><div class="admonition-body"><p>Old versions of Flux automatically installed CUDA.jl to provide GPU support. Starting from Flux v0.14, CUDA.jl is not a dependency anymore and has to be installed manually.</p></div></div><h2 id="Checking-GPU-Availability"><a class="docs-heading-anchor" href="#Checking-GPU-Availability">Checking GPU Availability</a><a id="Checking-GPU-Availability-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-GPU-Availability" title="Permalink"></a></h2><p>By default, Flux will run the checks on your system to see if it can support GPU functionality. You can check if Flux identified a valid GPU setup by typing the following:</p><pre><code class="language-julia hljs">julia&gt; using CUDA

julia&gt; CUDA.functional()
true</code></pre><p>For AMD GPU:</p><pre><code class="language-julia hljs">julia&gt; using AMDGPU

julia&gt; AMDGPU.functional()
true

julia&gt; AMDGPU.functional(:MIOpen)
true</code></pre><p>For Metal GPU:</p><pre><code class="language-julia hljs">julia&gt; using Metal

julia&gt; Metal.functional()
true</code></pre><h2 id="Selecting-GPU-backend"><a class="docs-heading-anchor" href="#Selecting-GPU-backend">Selecting GPU backend</a><a id="Selecting-GPU-backend-1"></a><a class="docs-heading-anchor-permalink" href="#Selecting-GPU-backend" title="Permalink"></a></h2><p>Available GPU backends are: <code>CUDA</code>, <code>AMDGPU</code> and <code>Metal</code>.</p><p>Flux relies on <a href="https://github.com/JuliaPackaging/Preferences.jl">Preferences.jl</a> for selecting default GPU backend to use.</p><p>There are two ways you can specify it:</p><ul><li>From the REPL/code in your project, call <code>Flux.gpu_backend!(&quot;AMDGPU&quot;)</code> and restart (if needed) Julia session for the changes to take effect.</li><li>In <code>LocalPreferences.toml</code> file in you project directory specify:</li></ul><pre><code class="language-toml hljs">[Flux]
gpu_backend = &quot;AMDGPU&quot;</code></pre><p>Current GPU backend can be fetched from <code>Flux.GPU_BACKEND</code> variable:</p><pre><code class="language-julia hljs">julia&gt; Flux.GPU_BACKEND
&quot;CUDA&quot;</code></pre><p>The current backend will affect the behaviour of methods like the method <code>gpu</code> described below.</p><h2 id="Basic-GPU-Usage"><a class="docs-heading-anchor" href="#Basic-GPU-Usage">Basic GPU Usage</a><a id="Basic-GPU-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-GPU-Usage" title="Permalink"></a></h2><p>Support for array operations on other hardware backends, like GPUs, is provided by external packages like <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a>, <a href="https://github.com/JuliaGPU/AMDGPU.jl">AMDGPU.jl</a>, and <a href="https://github.com/JuliaGPU/Metal.jl">Metal.jl</a>. Flux is agnostic to array types, so we simply need to move model weights and data to the GPU and Flux will handle it.</p><p>For example, we can use <code>CUDA.CuArray</code> (with the <code>cu</code> converter) to run our <a href="../models/basics/#man-basics">basic example</a> on an NVIDIA GPU.</p><p>(Note that you need to have CUDA available to use CUDA.CuArray – please see the <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a> instructions for more details.)</p><pre><code class="language-julia hljs">using CUDA

W = cu(rand(2, 5)) # a 2×5 CuArray
b = cu(rand(2))

predict(x) = W*x .+ b
loss(x, y) = sum((predict(x) .- y).^2)

x, y = cu(rand(5)), cu(rand(2)) # Dummy data
loss(x, y) # ~ 3</code></pre><p>Note that we convert both the parameters (<code>W</code>, <code>b</code>) and the data set (<code>x</code>, <code>y</code>) to cuda arrays. Taking derivatives and training works exactly as before.</p><p>If you define a structured model, like a <code>Dense</code> layer or <code>Chain</code>, you just need to convert the internal parameters. Flux provides <code>fmap</code>, which allows you to alter all parameters of a model at once.</p><pre><code class="language-julia hljs">d = Dense(10 =&gt; 5, σ)
d = fmap(cu, d)
d.weight # CuArray
d(cu(rand(10))) # CuArray output

m = Chain(Dense(10 =&gt; 5, σ), Dense(5 =&gt; 2), softmax)
m = fmap(cu, m)
m(cu(rand(10)))</code></pre><p>As a convenience, Flux provides the <code>gpu</code> function to convert models and data to the GPU if one is available. By default, it&#39;ll do nothing. So, you can safely call <code>gpu</code> on some data or model (as shown below), and the code will not error, regardless of whether the GPU is available or not. If a GPU library (e.g. CUDA) loads successfully, <code>gpu</code> will move data from the CPU to the GPU. As is shown below, this will change the type of something like a regular array to a <code>CuArray</code>.</p><pre><code class="language-julia hljs">julia&gt; using Flux, CUDA

julia&gt; m = Dense(10, 5) |&gt; gpu
Dense(10 =&gt; 5)      # 55 parameters

julia&gt; x = rand(10) |&gt; gpu
10-element CuArray{Float32, 1, CUDA.Mem.DeviceBuffer}:
 0.066846445
 ⋮
 0.76706964

julia&gt; m(x)
5-element CuArray{Float32, 1, CUDA.Mem.DeviceBuffer}:
 -0.99992573
 ⋮
 -0.547261</code></pre><p>The analogue <code>cpu</code> is also available for moving models and data back off of the GPU.</p><pre><code class="language-julia hljs">julia&gt; x = rand(10) |&gt; gpu
10-element CuArray{Float32, 1, CUDA.Mem.DeviceBuffer}:
 0.8019236
 ⋮
 0.7766742

julia&gt; x |&gt; cpu
10-element Vector{Float32}:
 0.8019236
 ⋮
 0.7766742</code></pre><h2 id="Transferring-Training-Data"><a class="docs-heading-anchor" href="#Transferring-Training-Data">Transferring Training Data</a><a id="Transferring-Training-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Transferring-Training-Data" title="Permalink"></a></h2><p>In order to train the model using the GPU both model and the training data have to be transferred to GPU memory. Moving the data can be done in two different ways:</p><ol><li><p>Iterating over the batches in a <a href="../../reference/data/mlutils/#DataLoader"><code>DataLoader</code></a> object transferring each one of the training batches at a time to the GPU. This is recommended for large datasets. Done by hand, it might look like this:</p><pre><code class="language-julia hljs">train_loader = Flux.DataLoader((X, Y), batchsize=64, shuffle=true)
# ... model definition, optimiser setup
for epoch in 1:epochs
    for (x_cpu, y_cpu) in train_loader
        x = gpu(x_cpu)
        y = gpu(y_cpu)
        grads = gradient(m -&gt; loss(m, x, y), model)
        Flux.update!(opt_state, model, grads[1])
    end
end</code></pre><p>Rather than write this out every time, you can just call <code>gpu(::DataLoader)</code>:</p><pre><code class="language-julia hljs">gpu_train_loader = Flux.DataLoader((X, Y), batchsize=64, shuffle=true) |&gt; gpu
# ... model definition, optimiser setup
for epoch in 1:epochs
    for (x, y) in gpu_train_loader
        grads = gradient(m -&gt; loss(m, x, y), model)
        Flux.update!(opt_state, model, grads[1])
    end
end</code></pre><p>This is equivalent to <code>DataLoader(MLUtils.mapobs(gpu, (X, Y)); keywords...)</code>. Something similar can also be done with <a href="https://cuda.juliagpu.org/stable/usage/memory/#Batching-iterator"><code>CUDA.CuIterator</code></a>, <code>gpu_train_loader = CUDA.CuIterator(train_loader)</code>. However, this only works with a limited number of data types: <code>first(train_loader)</code> should be a tuple (or <code>NamedTuple</code>) of arrays.</p></li><li><p>Transferring all training data to the GPU at once before creating the <code>DataLoader</code>. This is usually performed for smaller datasets which are sure to fit in the available GPU memory.</p><pre><code class="language-julia hljs">gpu_train_loader = Flux.DataLoader((X, Y) |&gt; gpu, batchsize = 32)
# ...
for epoch in 1:epochs
    for (x, y) in gpu_train_loader
        # ...</code></pre><p>Here <code>(X, Y) |&gt; gpu</code> applies <a href="../../reference/models/functors/#Flux.gpu-Tuple{Any}"><code>gpu</code></a> to both arrays, as it recurses into structures.</p></li></ol><h2 id="Saving-GPU-Trained-Models"><a class="docs-heading-anchor" href="#Saving-GPU-Trained-Models">Saving GPU-Trained Models</a><a id="Saving-GPU-Trained-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-GPU-Trained-Models" title="Permalink"></a></h2><p>After the training process is done, one must always transfer the trained model back to the <code>cpu</code> memory scope before serializing or saving to disk. This can be done, as described in the previous section, with:</p><pre><code class="language-julia hljs">model = cpu(model) # or model = model |&gt; cpu</code></pre><p>and then</p><pre><code class="language-julia hljs">using BSON
# ...
BSON.@save &quot;./path/to/trained_model.bson&quot; model

# in this approach the cpu-transferred model (referenced by the variable `model`)
# only exists inside the `let` statement
let model = cpu(model)
   # ...
   BSON.@save &quot;./path/to/trained_model.bson&quot; model
end

# is equivalent to the above, but uses `key=value` storing directive from BSON.jl
BSON.@save &quot;./path/to/trained_model.bson&quot; model = cpu(model)</code></pre><p>The reason behind this is that models trained in the GPU but not transferred to the CPU memory scope will expect <code>CuArray</code>s as input. In other words, Flux models expect input data coming from the same kind device in which they were trained on.</p><p>In controlled scenarios in which the data fed to the loaded models is garanteed to be in the GPU there&#39;s no need to transfer them back to CPU memory scope, however in production environments, where artifacts are shared among different processes, equipments or configurations, there is no garantee that the CUDA.jl package will be available for the process performing inference on the model loaded from the disk.</p><h2 id="Disabling-CUDA-or-choosing-which-GPUs-are-visible-to-Flux"><a class="docs-heading-anchor" href="#Disabling-CUDA-or-choosing-which-GPUs-are-visible-to-Flux">Disabling CUDA or choosing which GPUs are visible to Flux</a><a id="Disabling-CUDA-or-choosing-which-GPUs-are-visible-to-Flux-1"></a><a class="docs-heading-anchor-permalink" href="#Disabling-CUDA-or-choosing-which-GPUs-are-visible-to-Flux" title="Permalink"></a></h2><p>Sometimes it is required to control which GPUs are visible to <code>julia</code> on a system with multiple GPUs or disable GPUs entirely. This can be achieved with an environment variable <code>CUDA_VISIBLE_DEVICES</code>.</p><p>To disable all devices:</p><pre><code class="nohighlight hljs">$ export CUDA_VISIBLE_DEVICES=&#39;-1&#39;</code></pre><p>To select specific devices by device id:</p><pre><code class="nohighlight hljs">$ export CUDA_VISIBLE_DEVICES=&#39;0,1&#39;</code></pre><p>More information for conditional use of GPUs in CUDA.jl can be found in its <a href="https://cuda.juliagpu.org/stable/installation/conditional/#Conditional-use">documentation</a>, and information about the specific use of the variable is described in the <a href="https://developer.nvidia.com/blog/cuda-pro-tip-control-gpu-visibility-cuda_visible_devices/">Nvidia CUDA blog post</a>.</p><h2 id="Using-device-objects"><a class="docs-heading-anchor" href="#Using-device-objects">Using device objects</a><a id="Using-device-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Using-device-objects" title="Permalink"></a></h2><p>As a more convenient syntax, Flux allows the usage of GPU <code>device</code> objects which can be used to easily transfer models to GPUs (and defaulting to using the CPU if no GPU backend is available). This syntax has a few advantages including automatic selection of the GPU backend and type stability of data movement.  These features are provided by <a href="https://github.com/LuxDL/MLDataDevices.jl">MLDataDevices.jl</a> package, that Flux&#39;s uses internally and re-exports.</p><p>A <code>device</code> object can be created using the <a href="#MLDataDevices.gpu_device"><code>gpu_device</code></a> function.  <code>gpu_device</code> first checks for a GPU preference, and if possible returns a device for the preference backend. For instance, consider the following example, where we load the <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a> package to use an NVIDIA GPU (<code>&quot;CUDA&quot;</code> is the default preference):</p><pre><code class="language-julia-repl hljs">julia&gt; using Flux, CUDA;

julia&gt; device = gpu_device()   # returns handle to an NVIDIA GPU if available
(::CUDADevice{Nothing}) (generic function with 4 methods)

julia&gt; model = Dense(2 =&gt; 3);

julia&gt; model.weight     # the model initially lives in CPU memory
3×2 Matrix{Float32}:
 -0.984794  -0.904345
  0.720379  -0.486398
  0.851011  -0.586942

julia&gt; model = model |&gt; device      # transfer model to the GPU
Dense(2 =&gt; 3)       # 9 parameters

julia&gt; model.weight
3×2 CuArray{Float32, 2, CUDA.Mem.DeviceBuffer}:
 -0.984794  -0.904345
  0.720379  -0.486398
  0.851011  -0.586942</code></pre><p>The device preference can also be set via the <a href="#MLDataDevices.gpu_backend!"><code>gpu_backend!</code></a> function. For instance, below we first set our device preference to <code>&quot;AMDGPU&quot;</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; gpu_backend!(&quot;AMDGPU&quot;)
[ Info: GPU backend has been set to AMDGPU. Restart Julia to use the new backend.</code></pre><p>If no functional GPU backend is available, the device will default to a CPU device.  You can also explictly request a CPU device by calling the <a href="#MLDataDevices.cpu_device"><code>cpu_device</code></a> function.</p><pre><code class="language-julia-repl hljs">julia&gt; using Flux, MLDataDevices

julia&gt; cdev = cpu_device()
(::CPUDevice{Nothing}) (generic function with 4 methods)

julia&gt; gdev = gpu_device(force=true)   # force GPU device, error if no GPU is available
(::CUDADevice{Nothing}) (generic function with 4 methods)

julia&gt; model = Dense(2 =&gt; 3);     # model in CPU memory

julia&gt; gmodel = model |&gt; gdev;    # transfer model to GPU

julia&gt; cmodel = gmodel |&gt; cdev;   # transfer model back to CPU</code></pre><h2 id="Data-movement-across-GPU-devices"><a class="docs-heading-anchor" href="#Data-movement-across-GPU-devices">Data movement across GPU devices</a><a id="Data-movement-across-GPU-devices-1"></a><a class="docs-heading-anchor-permalink" href="#Data-movement-across-GPU-devices" title="Permalink"></a></h2><p>Flux also supports getting handles to specific GPU devices, and transferring models from one GPU device to another GPU device from the same backend. Let&#39;s try it out for NVIDIA GPUs. First, we list all the available devices:</p><pre><code class="language-julia-repl hljs">julia&gt; using Flux, CUDA;

julia&gt; CUDA.devices()
CUDA.DeviceIterator() for 3 devices:
0. NVIDIA TITAN RTX
1. NVIDIA TITAN RTX
2. NVIDIA TITAN RTX</code></pre><p>Then, let&#39;s select the device with id <code>0</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; device0 = gpu_device(1)
(::CUDADevice{CuDevice}) (generic function with 4 methods)

julia&gt; device0.device
CuDevice(0): NVIDIA TITAN RTX</code></pre><p>Notice that indexing starts from <code>0</code> in the <code>CUDA.devices()</code> output, but <code>gpu_device!</code> expects the device id starting from <code>1</code>.</p><p>Then, let&#39;s move a simple dense layer to the GPU represented by <code>device0</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; dense_model = Dense(2 =&gt; 3)
Dense(2 =&gt; 3)       # 9 parameters

julia&gt; dense_model = dense_model |&gt; device0;

julia&gt; dense_model.weight
3×2 CuArray{Float32, 2, CUDA.DeviceMemory}:
 -0.142062  -0.131455
 -0.828134  -1.06552
  0.608595  -1.05375

julia&gt; CUDA.device(dense_model.weight)      # check the GPU to which dense_model is attached
CuDevice(0): NVIDIA TITAN RTX</code></pre><p>Next, we&#39;ll get a handle to the device with id <code>1</code>, and move <code>dense_model</code> to that device:</p><pre><code class="language-julia-repl hljs">julia&gt; device1 = gpu_device(2)
(::CUDADevice{CuDevice}) (generic function with 4 methods)

julia&gt; dense_model = dense_model |&gt; device1;    # don&#39;t directly print the model; see warning below

julia&gt; CUDA.device(dense_model.weight)
CuDevice(1): NVIDIA TITAN RTX</code></pre><p>Due to a limitation in <code>Metal.jl</code>, currently this kind of data movement across devices is only supported for <code>CUDA</code> and <code>AMDGPU</code> backends.</p><div class="admonition is-warning"><header class="admonition-header">Printing models after moving to a different device</header><div class="admonition-body"><p>Due to a limitation in how GPU packages currently work, printing models on the REPL after moving them to a GPU device which is different from the current device will lead to an error.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MLDataDevices.cpu_device" href="#MLDataDevices.cpu_device"><code>MLDataDevices.cpu_device</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cpu_device() -&gt; CPUDevice()</code></pre><p>Return a <code>CPUDevice</code> object which can be used to transfer data to CPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LuxDL/MLDataDevices.jl/blob/v1.2.0/src/public.jl#L181-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MLDataDevices.default_device_rng" href="#MLDataDevices.default_device_rng"><code>MLDataDevices.default_device_rng</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_device_rng(::AbstractDevice)</code></pre><p>Returns the default RNG for the device. This can be used to directly generate parameters and states on the device using <a href="https://github.com/LuxDL/WeightInitializers.jl">WeightInitializers.jl</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LuxDL/MLDataDevices.jl/blob/v1.2.0/src/public.jl#L210-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MLDataDevices.get_device" href="#MLDataDevices.get_device"><code>MLDataDevices.get_device</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_device(x) -&gt; dev::AbstractDevice | Exception | Nothing</code></pre><p>If all arrays (on the leaves of the structure) are on the same device, we return that device. Otherwise, we throw an error. If the object is device agnostic, we return <code>nothing</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Trigger Packages must be loaded for this to return the correct device.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>RNG types currently don&#39;t participate in device determination. We will remove this restriction in the future.</p></div></div><p>See also <a href="#MLDataDevices.get_device_type"><code>get_device_type</code></a> for a faster alternative that can be used for dispatch based on device type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LuxDL/MLDataDevices.jl/blob/v1.2.0/src/public.jl#L240-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MLDataDevices.gpu_device" href="#MLDataDevices.gpu_device"><code>MLDataDevices.gpu_device</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gpu_device(device_id::Union{Nothing, Integer}=nothing;
    force::Bool=false) -&gt; AbstractDevice</code></pre><p>Selects GPU device based on the following criteria:</p><ol><li>If <code>gpu_backend</code> preference is set and the backend is functional on the system, then that device is selected.</li><li>Otherwise, an automatic selection algorithm is used. We go over possible device backends in the order specified by <code>supported_gpu_backends()</code> and select the first functional backend.</li><li>If no GPU device is functional and  <code>force</code> is <code>false</code>, then <code>cpu_device()</code> is invoked.</li><li>If nothing works, an error is thrown.</li></ol><p><strong>Arguments</strong></p><ul><li><code>device_id::Union{Nothing, Integer}</code>: The device id to select. If <code>nothing</code>, then we return the last selected device or if none was selected then we run the autoselection and choose the current device using <code>CUDA.device()</code> or <code>AMDGPU.device()</code> or similar. If <code>Integer</code>, then we select the device with the given id. Note that this is <code>1</code>-indexed, in contrast to the <code>0</code>-indexed <code>CUDA.jl</code>. For example, <code>id = 4</code> corresponds to <code>CUDA.device!(3)</code>.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>device_id</code> is only applicable for <code>CUDA</code> and <code>AMDGPU</code> backends. For <code>Metal</code>, <code>oneAPI</code> and <code>CPU</code> backends, <code>device_id</code> is ignored and a warning is printed.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>gpu_device</code> won&#39;t select a CUDA device unless both CUDA.jl and cuDNN.jl are loaded. This is to ensure that deep learning operations work correctly. Nonetheless, if cuDNN is not loaded you can still manually create a <code>CUDADevice</code> object and use it (e.g. <code>dev = CUDADevice()</code>).</p></div></div><p><strong>Keyword Arguments</strong></p><ul><li><code>force::Bool</code>: If <code>true</code>, then an error is thrown if no functional GPU device is found.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LuxDL/MLDataDevices.jl/blob/v1.2.0/src/public.jl#L67-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MLDataDevices.gpu_backend!" href="#MLDataDevices.gpu_backend!"><code>MLDataDevices.gpu_backend!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gpu_backend!() = gpu_backend!(&quot;&quot;)
gpu_backend!(backend) = gpu_backend!(string(backend))
gpu_backend!(backend::AbstractGPUDevice)
gpu_backend!(backend::String)</code></pre><p>Creates a <code>LocalPreferences.toml</code> file with the desired GPU backend.</p><p>If <code>backend == &quot;&quot;</code>, then the <code>gpu_backend</code> preference is deleted. Otherwise, <code>backend</code> is validated to be one of the possible backends and the preference is set to <code>backend</code>.</p><p>If a new backend is successfully set, then the Julia session must be restarted for the change to take effect.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LuxDL/MLDataDevices.jl/blob/v1.2.0/src/public.jl#L139-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MLDataDevices.get_device_type" href="#MLDataDevices.get_device_type"><code>MLDataDevices.get_device_type</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_device_type(x) -&gt; Type{&lt;:AbstractDevice} | Exception | Type{Nothing}</code></pre><p>Similar to <a href="#MLDataDevices.get_device"><code>get_device</code></a> but returns the type of the device instead of the device itself. This value is often a compile time constant and is recommended to be used instead of <a href="#MLDataDevices.get_device"><code>get_device</code></a> where ever defining dispatches based on the device type.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Trigger Packages must be loaded for this to return the correct device.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>RNG types currently don&#39;t participate in device determination. We will remove this restriction in the future.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LuxDL/MLDataDevices.jl/blob/v1.2.0/src/public.jl#L253-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MLDataDevices.reset_gpu_device!" href="#MLDataDevices.reset_gpu_device!"><code>MLDataDevices.reset_gpu_device!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset_gpu_device!()</code></pre><p>Resets the selected GPU device. This is useful when automatic GPU selection needs to be run again.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LuxDL/MLDataDevices.jl/blob/v1.2.0/src/public.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MLDataDevices.supported_gpu_backends" href="#MLDataDevices.supported_gpu_backends"><code>MLDataDevices.supported_gpu_backends</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">supported_gpu_backends() -&gt; Tuple{String, ...}</code></pre><p>Return a tuple of supported GPU backends.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This is not the list of functional backends on the system, but rather backends which <code>MLDataDevices.jl</code> supports.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LuxDL/MLDataDevices.jl/blob/v1.2.0/src/public.jl#L55-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MLDataDevices.DeviceIterator" href="#MLDataDevices.DeviceIterator"><code>MLDataDevices.DeviceIterator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DeviceIterator(dev::AbstractDevice, iterator)</code></pre><p>Create a <code>DeviceIterator</code> that iterates through the provided <code>iterator</code> via <code>iterate</code>. Upon each iteration, the current batch is copied to the device <code>dev</code>, and the previous iteration is marked as freeable from GPU memory (via <code>unsafe_free!</code>) (no-op for a CPU device).</p><p>The conversion follows the same semantics as <code>dev(&lt;item from iterator&gt;)</code>.</p><div class="admonition is-success"><header class="admonition-header">Similarity to `CUDA.CuIterator`</header><div class="admonition-body"><p>The design inspiration was taken from <code>CUDA.CuIterator</code> and was generalized to work with other backends and more complex iterators (using <code>Functors</code>).</p></div></div><div class="admonition is-success"><header class="admonition-header">`MLUtils.DataLoader`</header><div class="admonition-body"><p>Calling <code>dev(::MLUtils.DataLoader)</code> will automatically convert the dataloader to use the same semantics as <code>DeviceIterator</code>. This is generally preferred over looping over the dataloader directly and transferring the data to the device.</p></div></div><p><strong>Examples</strong></p><p>The following was run on a computer with an NVIDIA GPU.</p><pre><code class="language-julia-repl hljs">julia&gt; using MLDataDevices, MLUtils

julia&gt; X = rand(Float64, 3, 33);

julia&gt; dataloader = DataLoader(X; batchsize=13, shuffle=false);

julia&gt; for (i, x) in enumerate(dataloader)
           @show i, summary(x)
       end
(i, summary(x)) = (1, &quot;3×13 Matrix{Float64}&quot;)
(i, summary(x)) = (2, &quot;3×13 Matrix{Float64}&quot;)
(i, summary(x)) = (3, &quot;3×7 Matrix{Float64}&quot;)

julia&gt; for (i, x) in enumerate(CUDADevice()(dataloader))
           @show i, summary(x)
       end
(i, summary(x)) = (1, &quot;3×13 CuArray{Float32, 2, CUDA.DeviceMemory}&quot;)
(i, summary(x)) = (2, &quot;3×13 CuArray{Float32, 2, CUDA.DeviceMemory}&quot;)
(i, summary(x)) = (3, &quot;3×7 CuArray{Float32, 2, CUDA.DeviceMemory}&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LuxDL/MLDataDevices.jl/blob/v1.2.0/src/iterator.jl#L1-L46">source</a></section></article><h2 id="Distributed-data-parallel-training"><a class="docs-heading-anchor" href="#Distributed-data-parallel-training">Distributed data parallel training</a><a id="Distributed-data-parallel-training-1"></a><a class="docs-heading-anchor-permalink" href="#Distributed-data-parallel-training" title="Permalink"></a></h2><div class="admonition is-danger"><header class="admonition-header">Experimental</header><div class="admonition-body"><p>Distributed support is experimental and could change in the future.</p></div></div><p>Flux supports now distributed data parallel training with <code>DistributedUtils</code> module.  If you want to run your code on multiple GPUs, you have to install <code>MPI.jl</code> (see <a href="https://juliaparallel.org/MPI.jl/stable/usage/">docs</a> for more info).</p><pre><code class="language-julia-repl hljs">julia&gt; using MPI

julia&gt; MPI.install_mpiexecjl()</code></pre><p>Now you can run your code with <code>mpiexecjl --project=. -n &lt;np&gt; julia &lt;filename&gt;.jl</code> from CLI.</p><p>You can use either the <code>MPIBackend</code> or <code>NCCLBackend</code>, the latter only if also <code>NCCL.jl</code> is loaded. First, initialize a backend with <code>DistributedUtils.initialize</code>, e.g.</p><pre><code class="language-julia-repl hljs">julia&gt; using Flux, MPI, NCCL, CUDA

julia&gt; CUDA.allowscalar(false)

julia&gt; DistributedUtils.initialize(NCCLBackend)

julia&gt; backend = DistributedUtils.get_distributed_backend(NCCLBackend)
NCCLBackend{Communicator, MPIBackend{MPI.Comm}}(Communicator(Ptr{NCCL.LibNCCL.ncclComm} @0x000000000607a660), MPIBackend{MPI.Comm}(MPI.Comm(1140850688)))</code></pre><p>Pass your model, as well as any data to GPU device.</p><pre><code class="language-julia-repl hljs">julia&gt; model = Chain(Dense(1 =&gt; 256, tanh), Dense(256 =&gt; 1)) |&gt; gpu
Chain(
  Dense(1 =&gt; 256, tanh),                # 512 parameters
  Dense(256 =&gt; 1),                      # 257 parameters
)                   # Total: 4 arrays, 769 parameters, 744 bytes.

julia&gt; x = rand(Float32, 1, 16) |&gt; gpu
1×16 CUDA.CuArray{Float32, 2, CUDA.DeviceMemory}:
 0.239324  0.331029  0.924996  0.55593  0.853093  0.874513  0.810269  0.935858  0.477176  0.564591  0.678907  0.729682  0.96809  0.115833  0.66191  0.75822

julia&gt; y = x .^ 3
1×16 CUDA.CuArray{Float32, 2, CUDA.DeviceMemory}:
 0.0137076  0.0362744  0.791443  0.171815  0.620854  0.668804  0.53197  0.819654  0.108651  0.179971  0.312918  0.388508  0.907292  0.00155418  0.29  0.435899</code></pre><p>In this case, we are training on a total of <code>16 * number of processes</code> samples. You can also use <code>DistributedUtils.DistributedDataContainer</code> to split the data uniformly across processes (or do it manually).</p><pre><code class="language-julia-repl hljs">julia&gt; data = DistributedUtils.DistributedDataContainer(backend, x)
Flux.DistributedUtils.DistributedDataContainer(Float32[0.23932439 0.33102947 … 0.66191036 0.75822026], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])</code></pre><p>You have to wrap your model in <code>DistributedUtils.FluxDistributedModel</code> and synchronize it (broadcast accross all processes):</p><pre><code class="language-julia-repl hljs">julia&gt; model = DistributedUtils.synchronize!!(backend, DistributedUtils.FluxDistributedModel(model); root=0)
Chain(
  Dense(1 =&gt; 256, tanh),                # 512 parameters

  Dense(256 =&gt; 1),                      # 257 parameters
)                   # Total: 4 arrays, 769 parameters, 744 bytes.</code></pre><p>Time to set up an optimizer by using <code>DistributedUtils.DistributedOptimizer</code> and synchronize it as well.</p><pre><code class="language-julia-repl hljs">julia&gt; using Optimisers

julia&gt; opt = DistributedUtils.DistributedOptimizer(backend, Optimisers.Adam(0.001f0))
DistributedOptimizer{MPIBackend{Comm}}(MPIBackend{Comm}(Comm(1140850688)), Adam(0.001, (0.9, 0.999), 1.0e-8))

julia&gt; st_opt = Optimisers.setup(opt, model)
(layers = ((weight = Leaf(DistributedOptimizer{MPIBackend{Comm}}(MPIBackend{Comm}(Comm(1140850688)), Adam(0.001, (0.9, 0.999), 1.0e-8)), (Float32[0.0; 0.0; … ; 0.0; 0.0;;], Float32[0.0; 0.0; … ; 0.0; 0.0;;], (0.9, 0.999))), bias = Leaf(DistributedOptimizer{MPIBackend{Comm}}(MPIBackend{Comm}(Comm(1140850688)), Adam(0.001, (0.9, 0.999), 1.0e-8)), (Float32[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Float32[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], (0.9, 0.999))), σ = ()), (weight = Leaf(DistributedOptimizer{MPIBackend{Comm}}(MPIBackend{Comm}(Comm(1140850688)), Adam(0.001, (0.9, 0.999), 1.0e-8)), (Float32[0.0 0.0 … 0.0 0.0], Float32[0.0 0.0 … 0.0 0.0], (0.9, 0.999))), bias = Leaf(DistributedOptimizer{MPIBackend{Comm}}(MPIBackend{Comm}(Comm(1140850688)), Adam(0.001, (0.9, 0.999), 1.0e-8)), (Float32[0.0], Float32[0.0], (0.9, 0.999))), σ = ())),)

julia&gt; st_opt = DistributedUtils.synchronize!!(backend, st_opt; root=0) 
(layers = ((weight = Leaf(DistributedOptimizer{MPIBackend{Comm}}(MPIBackend{Comm}(Comm(1140850688)), Adam(0.001, (0.9, 0.999), 1.0e-8)), (Float32[0.0; 0.0; … ; 0.0; 0.0;;], Float32[0.0; 0.0; … ; 0.0; 0.0;;], (0.9, 0.999))), bias = Leaf(DistributedOptimizer{MPIBackend{Comm}}(MPIBackend{Comm}(Comm(1140850688)), Adam(0.001, (0.9, 0.999), 1.0e-8)), (Float32[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Float32[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], (0.9, 0.999))), σ = ()), (weight = Leaf(DistributedOptimizer{MPIBackend{Comm}}(MPIBackend{Comm}(Comm(1140850688)), Adam(0.001, (0.9, 0.999), 1.0e-8)), (Float32[0.0 0.0 … 0.0 0.0], Float32[0.0 0.0 … 0.0 0.0], (0.9, 0.999))), bias = Leaf(DistributedOptimizer{MPIBackend{Comm}}(MPIBackend{Comm}(Comm(1140850688)), Adam(0.001, (0.9, 0.999), 1.0e-8)), (Float32[0.0], Float32[0.0], (0.9, 0.999))), σ = ())),)</code></pre><p>Now you can define loss and train the model.</p><pre><code class="language-julia-repl hljs">julia&gt; loss(model) = mean((model(x) .- y).^2)
loss (generic function with 1 method)

julia&gt; for epoch in 1:100
           global model, st_opt
           l, grad = Zygote.withgradient(loss, model)
           println(&quot;Epoch $epoch: Loss $l&quot;)
           st_opt, model = Optimisers.update(st_opt, model, grad[1])
         end
Epoch 1: Loss 0.011638729
Epoch 2: Loss 0.0116432225
Epoch 3: Loss 0.012763695
...</code></pre><p>Remember that in order to run it on multiple GPUs you have to run from CLI <code>mpiexecjl --project=. -n &lt;np&gt; julia &lt;filename&gt;.jl</code>, where  <code>&lt;np&gt;</code> is the number of processes that you want to use. The number of processes usually corresponds to the number of gpus.</p><p>By default <code>MPI.jl</code> MPI installation is CUDA-unaware so if you want to run it in CUDA-aware mode, read more <a href="https://juliaparallel.org/MPI.jl/stable/usage/#CUDA-aware-MPI-support">here</a> on custom installation and rebuilding <code>MPI.jl</code>.  Then test if your MPI is CUDA-aware by</p><pre><code class="language-julia-repl hljs">julia&gt; import Pkg
julia&gt; Pkg.test(&quot;MPI&quot;; test_args=[&quot;--backend=CUDA&quot;])</code></pre><p>If it is, set your local preference as below</p><pre><code class="language-julia-repl hljs">julia&gt; using Preferences
julia&gt; set_preferences!(&quot;Flux&quot;, &quot;FluxDistributedMPICUDAAware&quot; =&gt; true)</code></pre><div class="admonition is-warning"><header class="admonition-header">Known shortcomings</header><div class="admonition-body"><p>We don&#39;t run CUDA-aware tests so you&#39;re running it at own risk.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../models/recurrence/">« Recurrence</a><a class="docs-footer-nextpage" href="../saving/">Saving &amp; Loading »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Saturday 12 October 2024 14:11">Saturday 12 October 2024</span>. Using Julia version 1.11.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
